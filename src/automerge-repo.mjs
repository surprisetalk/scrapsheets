/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@automerge/automerge-repo@2.5.1/dist/entrypoints/fullfat.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{next as e}from"@automerge/automerge";import t from"https://cdn.jsdelivr.net/npm/debug@4.4.3/+esm";import{EventEmitter as s}from"https://cdn.jsdelivr.net/npm/eventemitter3@5.0.1/+esm";import{setup as n,assign as a,assertEvent as o,createActor as r,waitFor as i}from"https://cdn.jsdelivr.net/npm/xstate@5.24.0/+esm";import*as d from"https://cdn.jsdelivr.net/npm/uuid@9.0.1/+esm";import c from"https://esm.sh/bs58check@3.0.1?bundle-deps";import{Encoder as h,decode as u}from"https://cdn.jsdelivr.net/npm/cbor-x@1.6.0/+esm";import*as l from"https://esm.sh/@noble/hashes@1.3.3/sha256";import"@automerge/automerge";const m=e=>Array.from(e,(e=>e.toString(16).padStart(2,"0"))).join(""),g="automerge:",p=e=>{const[t,s,...n]=e.split("#");if(n.length>0)throw new Error("Invalid URL: contains multiple heads sections");const a=new RegExp(`^${g}(\\w+)$`),[,o]=t.match(a)||[],r=o,i=b(r);if(!i)throw new Error("Invalid document URL: "+e);if(void 0===s)return{binaryDocumentId:i,documentId:r};const d=""===s?[]:s.split("|");return{binaryDocumentId:i,hexHeads:d.map((e=>{try{return m(c.decode(e))}catch(t){throw new Error(`Invalid head in URL: ${e}`)}})),documentId:r,heads:d}},y=e=>{if(e instanceof Uint8Array||"string"==typeof e)return g+(e instanceof Uint8Array?w(e):e);const{documentId:t,heads:s}=e;if(void 0===t)throw new Error("Invalid documentId: "+t);const n=t instanceof Uint8Array?w(t):t;let a=`${g}${n}`;return void 0!==s&&(s.forEach((e=>{try{c.decode(e)}catch(t){throw new Error(`Invalid head: ${e}`)}})),a+="#"+s.join("|")),a},f=e=>{if("string"!=typeof e||!e||!e.startsWith(g))return!1;try{const{documentId:t,heads:s}=p(e);return!!S(t)&&!(s&&!s.every((e=>{try{return c.decode(e),!0}catch{return!1}})))}catch{return!1}},S=e=>{if("string"!=typeof e)return!1;return void 0!==b(e)},I=()=>{const e=d.v4(null,new Uint8Array(16));return y({documentId:e})},b=e=>c.decodeUnsafe(e),w=e=>c.encode(e),v=e=>e.map((e=>c.encode((e=>{if(e.length%2!=0)throw new Error("Hex string must have an even length");const t=new Uint8Array(e.length/2);for(let s=0;s<e.length;s+=2)t[s>>1]=parseInt(e.slice(s,s+2),16);return t})(e)))),D=e=>e.map((e=>m(c.decode(e)))),E=e=>{if(e instanceof Uint8Array)return w(e);if(f(e))return p(e).documentId;if(S(e))return e;if("string"==typeof(t=e)&&d.validate(t)){console.warn("Future versions will not support UUIDs as document IDs; use Automerge URLs instead.");const t=d.parse(e);return w(t)}var t;throw new Error(`Invalid AutomergeUrl: '${e}'`)};function H(e){return new h({tagUint8Array:!1,useRecords:!1}).encode(e)}var R=Object.freeze({__proto__:null,encode:H,decode:function(e){return u(e)}});const P=(e,t)=>((e,t)=>e.length===t.length&&e.every(((e,s)=>e===t[s])))(e,t);class C extends Error{constructor(e){super(e),this.name="TimeoutError"}}class A extends DOMException{constructor(e){super(e??"Operation aborted","AbortError")}}function $(e,t){let s=!1;return new Promise(((n,a)=>{t?.addEventListener("abort",(()=>{s||a(new A)}),{once:!0}),e.then((e=>{n(e)})).catch((e=>{a(e)})).finally((()=>{s=!0}))}))}class M extends s{documentId;#e;#t;#s;#n=e.init();#a=6e4;#o={};#r=new Map;constructor(s,i={}){super(),this.documentId=s,"timeoutDelay"in i&&i.timeoutDelay&&(this.#a=i.timeoutDelay),"heads"in i&&(this.#s=i.heads);const d=e.init();this.#e=t(`automerge-repo:dochandle:${this.documentId.slice(0,5)}`);const c=this.#a,h=n({types:{context:{},events:{}},actions:{onUpdate:a((({context:e,event:t})=>{const s=e.doc;o(t,G);const{callback:n}=t.payload;return{doc:n(s)}})),onDelete:a((()=>(this.emit("delete",{handle:this}),{doc:e.init()}))),onUnavailable:a((()=>({doc:e.init()}))),onUnload:a((()=>({doc:e.init()})))}}).createMachine({initial:"idle",context:{documentId:s,doc:d},on:{UPDATE:{actions:"onUpdate"},UNLOAD:".unloaded",DELETE:".deleted"},states:{idle:{on:{BEGIN:"loading"}},loading:{on:{REQUEST:"requesting",DOC_READY:"ready"},after:{[c]:"unavailable"}},requesting:{on:{DOC_UNAVAILABLE:"unavailable",DOC_READY:"ready"},after:{[c]:"unavailable"}},unavailable:{entry:"onUnavailable",on:{DOC_READY:"ready"}},ready:{},unloaded:{entry:"onUnload",on:{RELOAD:"loading"}},deleted:{entry:"onDelete",type:"final"}}});this.#t=r(h),this.#t.subscribe((e=>{const t=this.#n,s=e.context.doc;this.#e(`â†’ ${e.value} %o`,s),this.#i(t,s)})),this.#t.start(),this.begin()}get#d(){return this.#t?.getSnapshot().context.doc}get#c(){return this.#t?.getSnapshot().value}#h(e,t){const s=Array.isArray(e)?e:[e];return i(this.#t,(e=>s.some((t=>e.matches(t)))),{timeout:2*this.#a,...t})}#u(e){let t=null;if(this.#t.send({type:G,payload:{callback:s=>{try{return e(s)}catch(e){return t=e,s}}}}),t)throw t}#i(t,s){const n=e.getHeads(t),a=e.getHeads(s);if(!P(v(a),v(n))){this.emit("heads-changed",{handle:this,doc:s});const o=e.diff(s,n,a);o.length>0&&this.emit("change",{handle:this,doc:s,patches:o,patchInfo:{before:t,after:s,source:"change"}}),this.isReady()||this.#t.send({type:N})}this.#n=s}get url(){return y({documentId:this.documentId,heads:this.#s})}isReady=()=>this.inState(["ready"]);isUnloaded=()=>this.inState(["unloaded"]);isDeleted=()=>this.inState(["deleted"]);isUnavailable=()=>this.inState(["unavailable"]);inState=e=>e.some((e=>this.#t.getSnapshot().matches(e)));get state(){return this.#t.getSnapshot().value}async whenReady(e=["ready"],t){try{await(async(e,t)=>{let s;const n=new Promise(((e,n)=>{s=setTimeout((()=>n(new C(`withTimeout: timed out after ${t}ms`))),t)}));try{return await Promise.race([e,n])}finally{clearTimeout(s)}})(this.#h(e,t),this.#a)}catch(t){if((s=t)instanceof A||(s instanceof Error||DOMException&&s instanceof DOMException)&&"AbortError"===s.name)throw new A;throw console.log(`error waiting for ${this.documentId} to be in one of states: ${e.join(", ")}`),t}var s}doc(){if(!this.isReady())throw new Error("DocHandle is not ready");return this.#s?e.view(this.#d,D(this.#s)):this.#d}docSync(){return console.warn("docSync is deprecated. Use doc() instead. This function will be removed as part of the 2.0 release."),this.doc()}heads(){if(!this.isReady())throw new Error("DocHandle is not ready");return this.#s?this.#s:v(e.getHeads(this.#d))}begin(){this.#t.send({type:O})}history(){if(this.isReady())return e.topoHistoryTraversal(this.#d).map((e=>v([e])))}view(t){if(!this.isReady())throw new Error(`DocHandle#${this.documentId} is not ready. Check \`handle.isReady()\` before calling view().`);const s=JSON.stringify(t),n=this.#r.get(s);if(n)return n;const a=new M(this.documentId,{heads:t,timeoutDelay:this.#a});return a.update((()=>e.clone(this.#d))),a.doneLoading(),this.#r.set(s,a),a}diff(t,s){if(!this.isReady())throw new Error(`DocHandle#${this.documentId} is not ready. Check \`handle.isReady()\` before calling diff().`);const n=this.#d;if(!n)throw new Error("Document not available");if(t instanceof M){if(!t.isReady())throw new Error("Cannot diff against a handle that isn't ready");const s=t.heads();if(!s)throw new Error("Other document's heads not available");const a=e.merge(e.clone(n),t.doc());return e.diff(a,D(this.heads()),D(s))}const a=s?t:this.heads()||[],o=s||t;return e.diff(n,D(a),D(o))}metadata(t){if(this.isReady())return t||(t=this.heads()[0]),e.inspectChange(this.#d,D([t])[0])||void 0}update(e){this.#u(e)}doneLoading(){this.#t.send({type:N})}setSyncInfo(e,t){this.#o[e]=t,this.emit("remote-heads",{storageId:e,heads:t.lastHeads,timestamp:t.lastSyncTimestamp})}getRemoteHeads(e){return this.#o[e]?.lastHeads}getSyncInfo(e){return this.#o[e]}change(t,s={}){if(!this.isReady())throw new Error(`DocHandle#${this.documentId} is in ${this.state} and not ready. Check \`handle.isReady()\` before accessing the document.`);if(this.#s)throw new Error(`DocHandle#${this.documentId} is in view-only mode at specific heads. Use clone() to create a new document from this state.`);this.#u((n=>e.change(n,s,t)))}changeAt(t,s,n={}){if(!this.isReady())throw new Error(`DocHandle#${this.documentId} is not ready. Check \`handle.isReady()\` before accessing the document.`);if(this.#s)throw new Error(`DocHandle#${this.documentId} is in view-only mode at specific heads. Use clone() to create a new document from this state.`);let a;return this.#u((o=>{const r=e.changeAt(o,D(t),n,s);return a=r.newHeads?v(r.newHeads):void 0,r.newDoc})),a}isReadOnly(){return!!this.#s}merge(t){if(!this.isReady()||!t.isReady())throw new Error("Both handles must be ready to merge");if(this.#s)throw new Error(`DocHandle#${this.documentId} is in view-only mode at specific heads. Use clone() to create a new document from this state.`);const s=t.doc();this.update((t=>e.merge(t,s)))}unavailable(){this.#t.send({type:_})}request(){"loading"===this.#c&&this.#t.send({type:F})}unload(){this.#t.send({type:q})}reload(){this.#t.send({type:W})}delete(){this.#t.send({type:j})}broadcast(e){this.emit("ephemeral-message-outbound",{handle:this,data:new Uint8Array(H(e))})}metrics(){return e.stats(this.#d)}}const{IDLE:k,LOADING:U,REQUESTING:T,READY:x,UNLOADED:z,DELETED:L,UNAVAILABLE:B}={IDLE:"idle",LOADING:"loading",REQUESTING:"requesting",READY:"ready",UNLOADED:"unloaded",DELETED:"deleted",UNAVAILABLE:"unavailable"},O="BEGIN",F="REQUEST",N="DOC_READY",G="UPDATE",q="UNLOAD",W="RELOAD",j="DELETE",_="DOC_UNAVAILABLE";class Y extends s{#l=new Map;#m=new Set;#g=new Map;#p=new Set;#y=new Map;#e=t("automerge-repo:remote-heads-subscriptions");subscribeToRemotes(e){this.#e("subscribeToRemotes",e);const t=[];for(const s of e)this.#m.has(s)||(this.#m.add(s),t.push(s));t.length>0&&this.emit("change-remote-subs",{add:t,peers:Array.from(this.#p)})}unsubscribeFromRemotes(e){this.#e("subscribeToRemotes",e);const t=[];for(const s of e)this.#m.has(s)&&(this.#m.delete(s),this.#g.has(s)||t.push(s));t.length>0&&this.emit("change-remote-subs",{remove:t,peers:Array.from(this.#p)})}handleControlMessage(e){const t=[],s=[],n=[];if(this.#e("handleControlMessage",e),e.add)for(const s of e.add){let a=this.#g.get(s);(this.#m.has(s)||a)&&n.push(s),a||(a=new Set,this.#g.set(s,a),this.#m.has(s)||t.push(s)),a.add(e.senderId)}if(e.remove)for(const t of e.remove){const n=this.#g.get(t);n&&(n.delete(e.senderId),0!=n.size||this.#m.has(t)||s.push(t))}(t.length>0||s.length>0)&&this.emit("change-remote-subs",{peers:Array.from(this.#p),add:t,remove:s});for(const t of n){const s=this.#y.get(e.senderId);if(s)for(const n of s){const s=this.#l.get(n);if(!s)continue;const a=s.get(t);a&&this.emit("notify-remote-heads",{targetId:e.senderId,documentId:n,heads:a.lastHeads,timestamp:a.lastSyncTimestamp,storageId:t})}}}handleRemoteHeads(e){this.#e("handleRemoteHeads",e);const t=this.#f(e);for(const e of t)this.#m.has(e.storageId)&&this.emit("remote-heads-changed",e);for(const s of t)for(const t of this.#p)t!==e.senderId&&this.emit("notify-remote-heads",{targetId:t,documentId:s.documentId,heads:s.remoteHeads,timestamp:s.timestamp,storageId:s.storageId});for(const e of t){const t=this.#g.get(e.storageId);if(t)for(const s of t)this.#S(s,e.documentId)&&this.emit("notify-remote-heads",{targetId:s,documentId:e.documentId,heads:e.remoteHeads,timestamp:e.timestamp,storageId:e.storageId})}}handleImmediateRemoteHeadsChanged(e,t,s){this.#e("handleLocalHeadsChanged",e,t,s);const n=this.#l.get(e),a=Date.now();if(n){const e=n.get(t);(!e||e.lastSyncTimestamp<Date.now())&&n.set(t,{lastSyncTimestamp:Date.now(),lastHeads:s})}else this.#l.set(e,new Map([[t,{lastSyncTimestamp:a,lastHeads:s}]]));const o=this.#g.get(t);if(o)for(const n of o)this.#S(n,e)&&this.emit("notify-remote-heads",{targetId:n,documentId:e,heads:s,timestamp:a,storageId:t})}addGenerousPeer(e){this.#e("addGenerousPeer",e),this.#p.add(e),this.#m.size>0&&this.emit("change-remote-subs",{add:Array.from(this.#m),peers:[e]});for(const[t,s]of this.#l)for(const[n,{lastHeads:a,lastSyncTimestamp:o}]of s)this.emit("notify-remote-heads",{targetId:e,documentId:t,heads:a,timestamp:o,storageId:n})}removePeer(e){this.#e("removePeer",e);const t=[];this.#p.delete(e),this.#y.delete(e);for(const[s,n]of this.#g)n.has(e)&&(n.delete(e),0==n.size&&(t.push(s),this.#g.delete(s)));t.length>0&&this.emit("change-remote-subs",{remove:t,peers:Array.from(this.#p)})}subscribePeerToDoc(e,t){let s=this.#y.get(e);s||(s=new Set,this.#y.set(e,s)),s.add(t);const n=this.#l.get(t);if(n)for(const[s,a]of n){const n=this.#g.get(s);n&&n.has(e)&&this.emit("notify-remote-heads",{targetId:e,documentId:t,heads:a.lastHeads,timestamp:a.lastSyncTimestamp,storageId:s})}}#S(e,t){const s=this.#y.get(e);return s&&s.has(t)}#f(e){const t=[],{documentId:s,newHeads:n}=e;for(const[e,{heads:a,timestamp:o}]of Object.entries(n)){if(!this.#m.has(e)&&!this.#g.has(e))continue;let n=this.#l.get(s);n||(n=new Map,this.#l.set(s,n));const r=n.get(e);r&&r.lastSyncTimestamp>=o||(n.set(e,{lastSyncTimestamp:o,lastHeads:a}),t.push({documentId:s,storageId:e,remoteHeads:a,timestamp:o}))}return t}}const Q=(e,t)=>{let s,n,a=Date.now();return function(...o){s=a+t-Date.now(),clearTimeout(n),n=setTimeout((()=>{e(...o),a=Date.now()}),s)}},V=e=>X(e)||Z(e)||K(e)||J(e)||ee(e)||te(e),J=e=>"doc-unavailable"===e.type,K=e=>"request"===e.type,X=e=>"sync"===e.type,Z=e=>"ephemeral"===e.type,ee=e=>"remote-subscription-change"===e.type,te=e=>"remote-heads-changed"===e.type;class se extends s{peerId;peerMetadata;#e;#I={};#b=0;#w=Math.random().toString(36).slice(2);#v={};adapters=[];constructor(e,s,n){super(),this.peerId=s,this.peerMetadata=n,this.#e=t(`automerge-repo:network:${this.peerId}`),e.forEach((e=>this.addNetworkAdapter(e)))}disconnect(){this.adapters.forEach((e=>e.disconnect()))}reconnect(){this.adapters.forEach((e=>e.connect(this.peerId)))}addNetworkAdapter(e){this.adapters.push(e),e.on("peer-candidate",(({peerId:t,peerMetadata:s})=>{this.#e(`peer candidate: ${t} `),this.#I[t]||(this.#I[t]=e),this.emit("peer",{peerId:t,peerMetadata:s})})),e.on("peer-disconnected",(({peerId:e})=>{this.#e(`peer disconnected: ${e} `),delete this.#I[e],this.emit("peer-disconnected",{peerId:e})})),e.on("message",(e=>{if(V(e))if(this.#e(`message from ${e.senderId}`),Z(e)){const s=`${(t=e).senderId}:${t.sessionId}`;(void 0===this.#v[s]||e.count>this.#v[s])&&(this.#v[s]=e.count,this.emit("message",e))}else{var t;this.emit("message",e)}else this.#e(`invalid message: ${JSON.stringify(e)}`)})),e.on("close",(()=>{this.#e("adapter closed"),Object.entries(this.#I).forEach((([t,s])=>{s===e&&delete this.#I[t]})),this.adapters=this.adapters.filter((t=>t!==e))})),this.peerMetadata.then((t=>{e.connect(this.peerId,t)})).catch((e=>{this.#e("error connecting to network",e)}))}removeNetworkAdapter(e){this.adapters=this.adapters.filter((t=>t!==e)),e.disconnect()}send(e){const t=this.#I[e.targetId];if(!t)return void this.#e(`Tried to send message but peer not found: ${e.targetId}`);const s=(e=>"ephemeral"===e.type?"count"in e?e:{...e,count:++this.#b,sessionId:this.#w,senderId:this.peerId}:{...e,senderId:this.peerId})(e);this.#e("sending message %o",s),t.send(s)}isReady=()=>this.adapters.every((e=>e.isReady()));whenReady=async()=>Promise.all(this.adapters.map((e=>e.whenReady())))}function ne(e){let t=0;e.forEach((e=>{t+=e.length}));const s=new Uint8Array(t);let n=0;return e.forEach((e=>{s.set(e,n),n+=e.length})),s}function ae(e){const t=l.hash(e);return s=t,Array.from(s,(e=>e.toString(16).padStart(2,"0"))).join("");var s}class oe extends s{#D;#E=new Map;#H=new Map;#R=!1;#e=t("automerge-repo:storage-subsystem");constructor(e){super(),this.#D=e}async id(){const e=await this.#D.load(["storage-adapter-id"]);let t;return e?t=(new TextDecoder).decode(e):(t=d.v4(),await this.#D.save(["storage-adapter-id"],(new TextEncoder).encode(t))),t}async load(e,t){const s=[e,t];return await this.#D.load(s)}async save(e,t,s){const n=[e,t];await this.#D.save(n,s)}async remove(e,t){const s=[e,t];await this.#D.remove(s)}async loadDocData(e){const t=await this.#D.loadRange([e,"snapshot"]),s=await this.#D.loadRange([e,"incremental"]),n=[],a=[];for(const e of t)void 0!==e.data&&(a.push({key:e.key,type:"snapshot",size:e.data.length}),n.push(e.data));for(const e of s)void 0!==e.data&&(a.push({key:e.key,type:"incremental",size:e.data.length}),n.push(e.data));return this.#H.set(e,a),0===n.length?null:ne(n)}async loadDoc(t){const s=await this.loadDocData(t);if(!s)return null;const n=performance.now(),a=e.loadIncremental(e.init(),s),o=performance.now();return this.emit("document-loaded",{documentId:t,durationMillis:o-n,...e.stats(a)}),this.#E.set(t,e.getHeads(a)),a}async saveDoc(t,s){if(!this.#P(t,s))return;const n=this.#H.get(t)??[];this.#C(n)?await this.#A(t,s,n):await this.#$(t,s),this.#E.set(t,e.getHeads(s))}async removeDoc(e){await this.#D.removeRange([e,"snapshot"]),await this.#D.removeRange([e,"incremental"]),await this.#D.removeRange([e,"sync-state"])}async#$(t,s){const n=this.#E.get(t)??[],a=performance.now(),o=e.saveSince(s,n),r=performance.now();if(this.emit("doc-saved",{documentId:t,durationMillis:r-a,sinceHeads:n}),!(o&&o.length>0))return Promise.resolve();{const n=[t,"incremental",ae(o)];this.#e(`Saving incremental ${n} for document ${t}`),await this.#D.save(n,o),this.#H.has(t)||this.#H.set(t,[]),this.#H.get(t).push({key:n,type:"incremental",size:o.length}),this.#E.set(t,e.getHeads(s))}}async#A(t,s,n){this.#R=!0;const a=performance.now(),o=e.save(s),r=performance.now();this.emit("doc-compacted",{documentId:t,durationMillis:r-a});const i=function(e){const t=new TextEncoder;return ae(ne(e.map((e=>t.encode(e)))))}(e.getHeads(s)),d=[t,"snapshot",i],c=new Set(n.map((e=>e.key)).filter((e=>e[2]!==i)));this.#e(`Saving snapshot ${d} for document ${t}`),this.#e(`deleting old chunks ${Array.from(c)}`),await this.#D.save(d,o);for(const e of c)await this.#D.remove(e);const h=this.#H.get(t)?.filter((e=>!c.has(e.key)))??[];h.push({key:d,type:"snapshot",size:o.length}),this.#H.set(t,h),this.#R=!1}async loadSyncState(t,s){const n=[t,"sync-state",s];try{const t=await this.#D.load(n);return t?e.decodeSyncState(t):void 0}catch(e){return void this.#e(`Error loading sync state for ${t} from ${s}`)}}async saveSyncState(t,s,n){const a=[t,"sync-state",s];await this.#D.save(a,e.encodeSyncState(n))}#P(t,s){const n=this.#E.get(t);if(!n)return!0;const a=e.getHeads(s);return!P(v(a),v(n))}#C(e){if(this.#R)return!1;let t=0,s=0;for(const n of e)"snapshot"===n.type?t+=n.size:s+=n.size;return t<1024||s>=t}}class re extends s{}class ie extends re{#e;syncDebounceRate=100;#M=[];#k={};#U={};#T={};#x=[];#z;#L=!1;#B;#O;constructor({handle:e,peerId:s,onLoadSyncState:n}){super(),this.#z=s,this.#B=e,this.#O=n??(()=>Promise.resolve(void 0));const a=e.documentId.slice(0,5);this.#e=t(`automerge-repo:docsync:${a}`),e.on("change",Q((()=>this.#F()),this.syncDebounceRate)),e.on("ephemeral-message-outbound",(e=>this.#N(e))),(async()=>{this.#G()})()}get peerStates(){return this.#U}get documentId(){return this.#B.documentId}async#F(){try{await this.#B.whenReady();const e=this.#B.doc();this.#M.forEach((t=>this.#q(t,e)))}catch(e){console.log("sync with peers threw an exception")}}async#N({data:e}){this.#e("broadcastToPeers",this.#M),this.#M.forEach((t=>this.#W(t,e)))}#W(e,t){this.#e(`sendEphemeralMessage ->${e}`);const s={type:"ephemeral",targetId:e,documentId:this.#B.documentId,data:t};this.emit("message",s)}#j(t,s){this.#_(t),t in this.#U||(this.#U[t]="unknown");const n=this.#T[t];if(n)return void s(n);let a=this.#k[t];a||(this.#O(t).then((s=>{this.#Y(t,s??e.initSyncState())})).catch((e=>{this.#e(`Error loading sync state for ${t}: ${e}`)})),a=this.#k[t]=[]),a.push(s)}#_(e){this.#M.includes(e)||(this.#M.push(e),this.emit("open-doc",{documentId:this.documentId,peerId:e}))}#Y(e,t){const s=this.#k[e];if(s)for(const e of s)e(t);delete this.#k[e],this.#T[e]=t}#Q(e,t){this.#T[e]=t,this.emit("sync-state",{peerId:e,syncState:t,documentId:this.#B.documentId})}#q(t,s){this.#e(`sendSyncMessage ->${t}`),this.#j(t,(n=>{const a=performance.now(),[o,r]=e.generateSyncMessage(s,n),i=performance.now();if(this.emit("metrics",{type:"generate-sync-message",documentId:this.#B.documentId,durationMillis:i-a,forPeer:t}),this.#Q(t,o),r){const n=0===e.getHeads(s).length;this.#B.isReady()||!n||0!==o.sharedHeads.length||Object.values(this.#U).includes("has")||"unknown"!==this.#U[t]?this.emit("message",{type:"sync",targetId:t,data:r,documentId:this.#B.documentId}):this.emit("message",{type:"request",targetId:t,documentId:this.#B.documentId,data:r}),n||(this.#U[t]="has")}}))}hasPeer(e){return this.#M.includes(e)}async beginSync(t){this.#B.whenReady([x,T,B]).then((()=>{this.#L=!0,this.#V()})).catch((e=>{console.log("caught whenready",e),this.#L=!0,this.#V()}));this.#M.some((e=>"has"==this.#U[e]))&&await this.#B.whenReady(),t.forEach((s=>{this.#j(s,(n=>{const a=e.decodeSyncState(e.encodeSyncState(n));this.#Q(s,a),this.#B.whenReady([x,T,B]).then((()=>{const n=this.#B.isReady()?this.#B.doc():e.init(),a=t.every((e=>this.#U[e]in["unavailable","wants"]));void 0===n&&a||this.#q(s,n??e.init())})).catch((e=>{this.#e(`Error loading doc for ${s}: ${e}`)}))}))}))}endSync(e){this.#e(`removing peer ${e}`),this.#M=this.#M.filter((t=>t!==e)),delete this.#U[e],this.#V()}receiveMessage(e){switch(e.type){case"sync":case"request":this.receiveSyncMessage(e);break;case"ephemeral":this.receiveEphemeralMessage(e);break;case"doc-unavailable":this.#U[e.senderId]="unavailable",this.#V();break;default:throw new Error(`unknown message type: ${e}`)}}receiveEphemeralMessage(e){if(e.documentId!==this.#B.documentId)throw new Error("channelId doesn't match documentId");const{senderId:t,data:s}=e,n=u(new Uint8Array(s));this.#B.emit("ephemeral-message",{handle:this.#B,senderId:t,message:n}),this.#M.forEach((s=>{s!==t&&this.emit("message",{...e,targetId:s})}))}receiveSyncMessage(e){if(e.documentId!==this.#B.documentId)throw new Error("channelId doesn't match documentId");this.#B.inState([x,T,B])?(this.#G(),this.#J(e)):this.#x.push({message:e,received:new Date})}#J(t){K(t)&&(this.#U[t.senderId]="wants"),this.#V(),e.decodeSyncMessage(t.data).heads.length>0&&(this.#U[t.senderId]="has"),this.#j(t.senderId,(s=>{this.#B.update((n=>{const a=performance.now(),[o,r]=e.receiveSyncMessage(n,s,t.data),i=performance.now();return this.emit("metrics",{type:"receive-sync-message",documentId:this.#B.documentId,durationMillis:i-a,fromPeer:t.senderId,...e.stats(n)}),this.#Q(t.senderId,r),this.#q(t.senderId,n),o})),this.#V()}))}#V(){this.#L&&this.#B.inState([T,B])&&this.#M.every((e=>"unavailable"===this.#U[e]||"wants"===this.#U[e]))&&(this.#M.filter((e=>"wants"===this.#U[e])).forEach((e=>{this.#U[e]="unavailable";const t={type:"doc-unavailable",documentId:this.#B.documentId,targetId:e};this.emit("message",t)})),this.#B.unavailable())}#G(){for(const e of this.#x)this.#J(e.message);this.#x=[]}metrics(){return{peers:this.#M,size:this.#B.metrics()}}}const de=t("automerge-repo:collectionsync");class ce extends re{repo;#M=new Set;docSynchronizers={};#K={};#X;#Z=new Map;constructor(e,t=[]){super(),this.repo=e,this.#X=t.map((e=>p(e).documentId))}#ee(e){return this.docSynchronizers[e.documentId]||(this.docSynchronizers[e.documentId]=this.#te(e)),this.docSynchronizers[e.documentId]}#te(e){const t=new ie({handle:e,peerId:this.repo.networkSubsystem.peerId,onLoadSyncState:async t=>{if(!this.repo.storageSubsystem)return;const{storageId:s,isEphemeral:n}=this.repo.peerMetadataByPeerId[t]||{};return s&&!n?this.repo.storageSubsystem.loadSyncState(e.documentId,s):void 0}});return t.on("message",(e=>this.emit("message",e))),t.on("open-doc",(e=>this.emit("open-doc",e))),t.on("sync-state",(e=>this.emit("sync-state",e))),t.on("metrics",(e=>this.emit("metrics",e))),t}async#se(e){const t=Array.from(this.#M),s=[];for(const n of t){await this.#ne(n,e)&&s.push(n)}return s}async receiveMessage(e){de(`onSyncMessage: ${e.senderId}, ${e.documentId}, ${"data"in e?e.data.byteLength+"bytes":""}`);const t=e.documentId;if(!t)throw new Error("received a message with an invalid documentId");if(this.#X.includes(t))return this.emit("metrics",{type:"doc-denied",documentId:t}),void this.emit("message",{type:"doc-unavailable",documentId:t,targetId:e.senderId});"request"===e.type&&(this.#Z.has(t)||this.#Z.set(t,new Set),this.#Z.get(t)?.add(e.senderId));if(!await this.repo.shareConfig.access(e.senderId,t))return de("access denied"),void this.emit("message",{type:"doc-unavailable",documentId:t,targetId:e.senderId});this.#K[t]=!0;const s=await this.repo.find(t,{allowableStates:["ready","unavailable","requesting"]}),n=this.#ee(s);n.receiveMessage(e);const a=await this.#se(t);n.beginSync(a.filter((e=>!n.hasPeer(e))))}addDocument(e){if(this.#K[e.documentId])return;this.#K[e.documentId]=!0;const t=this.#ee(e);this.#se(e.documentId).then((e=>{t.beginSync(e)}))}removeDocument(e){de(`removing document ${e}`);const t=this.docSynchronizers[e];void 0!==t&&this.peers.forEach((e=>t.endSync(e))),delete this.docSynchronizers[e],delete this.#K[e]}addPeer(e){if(de(`adding ${e} & synchronizing with them`),!this.#M.has(e)){this.#M.add(e);for(const t of Object.values(this.docSynchronizers)){const{documentId:s}=t;this.#ne(e,s).then((s=>{s&&t.beginSync([e])}))}}}removePeer(e){de(`removing peer ${e}`),this.#M.delete(e);for(const t of this.#Z.values())t.delete(e);for(const t of Object.values(this.docSynchronizers))t.endSync(e)}get peers(){return Array.from(this.#M)}async reevaluateDocumentShare(){const e=Array.from(this.#M),t=[];for(const s of Object.values(this.docSynchronizers)){const n=s.documentId;t.push((async()=>{for(const t of e){const e=await this.#ne(t,n),a=s.hasPeer(t);de(`reevaluateDocumentShare: ${t} for ${n}, shouldShare: ${e}, isAlreadySyncing: ${a}`),e&&!a?(de(`reevaluateDocumentShare: starting sync with ${t} for ${n}`),s.beginSync([t])):!e&&a&&(de(`reevaluateDocumentShare: stopping sync with ${t} for ${n}`),s.endSync(t))}})().catch((e=>{console.log(`error reevaluating document share for ${n}: ${e}`)})))}await Promise.allSettled(t)}metrics(){return Object.fromEntries(Object.entries(this.docSynchronizers).map((([e,t])=>[e,t.metrics()])))}async#ne(e,t){const[s,n]=await Promise.all([this.repo.shareConfig.announce(e,t),this.repo.shareConfig.access(e,t)]),a=this.#Z.get(t)?.has(e)??!1;return s||n&&a}}function he(){return"peer-"+Math.random().toString(36).slice(4)}class ue extends s{#e;networkSubsystem;storageSubsystem;#ae;#oe;#re={};synchronizer;#ie={announce:async()=>!0,access:async()=>!0};peerMetadataByPeerId={};#de=new Y;#ce=!1;#he={};#ue={};#le;constructor({storage:e,network:s=[],peerId:n=he(),sharePolicy:a,shareConfig:o,isEphemeral:r=void 0===e,enableRemoteHeadsGossiping:i=!1,denylist:d=[],saveDebounceRate:c=100,idFactory:h}={}){if(super(),this.#ce=i,this.#e=t("automerge-repo:repo"),this.#le=h||null,null!=a&&null!=o)throw new Error("cannot provide both sharePolicy and shareConfig at once");a&&(this.#ie={announce:a,access:async()=>!0}),o&&(this.#ie=o),this.on("delete-document",(({documentId:e})=>{this.synchronizer.removeDocument(e),u&&u.removeDoc(e).catch((t=>{this.#e("error deleting document",{documentId:e,err:t})}))})),this.synchronizer=new ce(this,d),this.synchronizer.on("message",(e=>{this.#e(`sending ${e.type} message to ${e.targetId}`),m.send(e)})),this.synchronizer.on("metrics",(e=>this.emit("doc-metrics",e))),this.#ce&&this.synchronizer.on("open-doc",(({peerId:e,documentId:t})=>{this.#de.subscribePeerToDoc(e,t)}));const u=e?new oe(e):void 0;u&&(u.on("document-loaded",(e=>this.emit("doc-metrics",{type:"doc-loaded",...e}))),u.on("doc-compacted",(e=>this.emit("doc-metrics",{type:"doc-compacted",...e}))),u.on("doc-saved",(e=>this.emit("doc-metrics",{type:"doc-saved",...e})))),this.storageSubsystem=u,this.#ae=c,this.storageSubsystem?this.#oe=({handle:e,doc:t})=>{let s=this.#ue[e.documentId];s||(s=Q((({doc:e,handle:t})=>{this.storageSubsystem.saveDoc(t.documentId,e)}),this.#ae),this.#ue[e.documentId]=s),s({handle:e,doc:t})}:this.#oe=()=>{};const l=(async()=>({storageId:await(u?.id()),isEphemeral:r}))(),m=new se(s,n,l);this.networkSubsystem=m,m.on("peer",(async({peerId:e,peerMetadata:t})=>{this.#e("peer connected",{peerId:e}),t&&(this.peerMetadataByPeerId[e]={...t}),this.#ie.announce(e).then((t=>{t&&this.#ce&&this.#de.addGenerousPeer(e)})).catch((e=>{console.log("error in share policy",{err:e})})),this.synchronizer.addPeer(e)})),m.on("peer-disconnected",(({peerId:e})=>{this.synchronizer.removePeer(e),this.#de.removePeer(e)})),m.on("message",(async e=>{this.#me(e)})),this.synchronizer.on("sync-state",(e=>{this.#ge(e);const t=this.#re[e.documentId],{storageId:s}=this.peerMetadataByPeerId[e.peerId]||{};if(!s)return;const n=t.getSyncInfo(s)?.lastHeads;e.syncState.theirHeads&&(!n||!P(n,v(e.syncState.theirHeads)))&&e.syncState.theirHeads&&(t.setSyncInfo(s,{lastHeads:v(e.syncState.theirHeads),lastSyncTimestamp:Date.now()}),s&&this.#ce&&this.#de.handleImmediateRemoteHeadsChanged(e.documentId,s,v(e.syncState.theirHeads)))})),this.#ce&&(this.#de.on("notify-remote-heads",(e=>{this.networkSubsystem.send({type:"remote-heads-changed",targetId:e.targetId,documentId:e.documentId,newHeads:{[e.storageId]:{heads:e.heads,timestamp:e.timestamp}}})})),this.#de.on("change-remote-subs",(e=>{this.#e("change-remote-subs",e);for(const t of e.peers)this.networkSubsystem.send({type:"remote-subscription-change",targetId:t,add:e.add,remove:e.remove})})),this.#de.on("remote-heads-changed",(({documentId:e,storageId:t,remoteHeads:s,timestamp:n})=>{this.#re[e].setSyncInfo(t,{lastHeads:s,lastSyncTimestamp:n})})))}#pe(e){if(this.storageSubsystem){e.listeners("heads-changed").some((e=>e===this.#oe))||e.on("heads-changed",this.#oe)}this.synchronizer.addDocument(e)}#me(e){switch(e.type){case"remote-subscription-change":this.#ce&&this.#de.handleControlMessage(e);break;case"remote-heads-changed":this.#ce&&this.#de.handleRemoteHeads(e);break;case"sync":case"request":case"ephemeral":case"doc-unavailable":this.synchronizer.receiveMessage(e).catch((t=>{console.log("error receiving message",{err:t,message:e})}))}}#ye={};#ge(e){if(!this.storageSubsystem)return;const{storageId:t,isEphemeral:s}=this.peerMetadataByPeerId[e.peerId]||{};if(!t||s)return;let n=this.#ye[t];n||(n=this.#ye[t]=Q((({documentId:e,syncState:s})=>{this.storageSubsystem.saveSyncState(e,t,s)}),this.#ae)),n(e)}#fe({documentId:e}){if(this.#re[e])return this.#re[e];if(!e)throw new Error(`Invalid documentId ${e}`);const t=new M(e);return this.#re[e]=t,t}get handles(){return this.#re}get peers(){return this.synchronizer.peers}get peerId(){return this.networkSubsystem.peerId}get sharePolicy(){return this.#ie.announce}set sharePolicy(e){this.#ie.announce=e}get shareConfig(){return this.#ie}set shareConfig(e){this.#ie=e}getStorageIdOfPeer(e){return this.peerMetadataByPeerId[e]?.storageId}create(t){let s;s=t?e.from(t):e.emptyChange(e.init());const{documentId:n}=p(I()),a=this.#fe({documentId:n});return this.#pe(a),a.update((()=>s)),a.doneLoading(),a}async create2(t){let s;s=t?e.from(t):e.emptyChange(e.init());let{documentId:n}=p(I());if(this.#le){const t=await this.#le(e.getHeads(s));n=w(t)}const a=this.#fe({documentId:n});return this.#pe(a),a.update((()=>s)),a.doneLoading(),a}clone(t){if(!t.isReady())throw new Error("Cloned handle is not yet in ready state.\n        (Try await handle.whenReady() first.)");const s=t.doc(),n=this.create();return n.update((()=>e.clone(s))),n}findWithProgress(e,t={}){const{signal:s}=t,{documentId:n,heads:a}=f(e)?p(e):{documentId:E(e),heads:void 0};if(this.#re[n]){const t=this.#re[n];if(t.state===B){return{state:"unavailable",error:new Error(`Document ${e} is unavailable`),handle:t}}if(t.state===L){return{state:"failed",error:new Error(`Document ${e} was deleted`),handle:t}}if(t.state===x){return{state:"ready",handle:a?t.view(a):t}}}const o=this.#he[n];if(o){const e=this.#re[n];if(e&&(e.state===x||e.state===B||e.state===L||"loading"===e.state))return o}const r=this.#fe({documentId:n}),i={state:"loading",progress:0,handle:r},d={subscribers:new Set,currentProgress:void 0,notify:e=>{d.currentProgress=e,d.subscribers.forEach((t=>t(e))),this.#he[n]=e},peek:()=>d.currentProgress||i,subscribe:e=>(d.subscribers.add(e),()=>d.subscribers.delete(e))};d.notify(i),this.#Se(e,n,r,d,s?$(new Promise((()=>{})),s):new Promise((()=>{})));const c={...i,peek:d.peek,subscribe:d.subscribe};return this.#he[n]=c,c}async#Se(e,t,s,n,a){try{n.notify({state:"loading",progress:25,handle:s});const t=await(this.storageSubsystem?this.storageSubsystem.loadDoc(s.documentId):Promise.resolve(null)),o=await Promise.race([t,a]);if(o?(s.update((()=>o)),s.doneLoading(),n.notify({state:"loading",progress:50,handle:s})):(await Promise.race([this.networkSubsystem.whenReady(),a]),s.request(),n.notify({state:"loading",progress:75,handle:s})),this.#pe(s),await Promise.race([s.whenReady([x,B]),a]),s.state===B){const e={state:"unavailable",handle:s};return void n.notify(e)}if(s.state===L)throw new Error(`Document ${e} was deleted`);n.notify({state:"ready",handle:s})}catch(e){n.notify({state:"failed",error:e instanceof Error||e instanceof DOMException?e:new Error(String(e)),handle:this.#fe({documentId:t})})}}async find(e,t={}){const{allowableStates:s=["ready"],signal:n}=t;if(n?.aborted)throw new A;const a=this.findWithProgress(e,{signal:n});if("subscribe"in a)return this.#pe(a.handle),new Promise(((t,n)=>{const o=a.subscribe((a=>{s.includes(a.handle.state)?(o(),t(a.handle)):"unavailable"===a.state?(o(),n(new Error(`Document ${e} is unavailable`))):"failed"===a.state&&(o(),n(a.error))}))}));if(a.handle.state===x)return a.handle;if(await a.handle.whenReady([x,B]),"unavailable"===a.handle.state&&!s.includes(B))throw new Error(`Document ${e} is unavailable`);return a.handle}async#Ie(e){if(this.#re[e])return this.#re[e];const t=this.#fe({documentId:e}),s=await(this.storageSubsystem?this.storageSubsystem.loadDoc(t.documentId):Promise.resolve(null));return s?(t.update((()=>s)),t.doneLoading()):(await this.networkSubsystem.whenReady(),t.request()),this.#pe(t),t}async findClassic(e,t={}){const s=E(e),{allowableStates:n,signal:a}=t;return $((async()=>{const t=await this.#Ie(s);if(!n&&(await t.whenReady([x,B]),t.state===B&&!a?.aborted))throw new Error(`Document ${e} is unavailable`);return t})(),a)}delete(e){const t=E(e);this.#fe({documentId:t}).delete(),delete this.#re[t],delete this.#he[t],delete this.#ue[t],this.emit("delete-document",{documentId:t})}async export(t){const s=E(t),n=this.#fe({documentId:s}).doc();return e.save(n)}import(t,s){const n=s?.docId;if(null!=n){const s=this.#fe({documentId:n});return s.update((s=>e.loadIncremental(s,t))),this.#pe(s),s}{const s=e.load(t),n=this.create();return n.update((()=>e.clone(s))),n}}subscribeToRemotes=e=>{this.#ce?(this.#e("subscribeToRemotes",{remotes:e}),this.#de.subscribeToRemotes(e)):this.#e("WARN: subscribeToRemotes called but remote heads gossiping is not enabled")};storageId=async()=>this.storageSubsystem?this.storageSubsystem.id():void 0;async flush(e){if(!this.storageSubsystem)return;const t=e?e.map((e=>this.#re[e])):Object.values(this.#re);await Promise.all(t.map((async e=>this.storageSubsystem.saveDoc(e.documentId,e.doc()))))}async removeFromCache(e){if(!this.#re[e])return void this.#e(`WARN: removeFromCache called but handle not found in handleCache for documentId: ${e}`);const t=this.#fe({documentId:e});await t.whenReady([x,z,L,B]);t.doc()?(t.isReady()?t.unload():this.#e(`WARN: removeFromCache called but handle for documentId: ${e} in unexpected state: ${t.state}`),delete this.#re[e],delete this.#he[e],delete this.#ue[e],this.synchronizer.removeDocument(e)):this.#e(`WARN: removeFromCache called but doc undefined for documentId: ${e}`)}shutdown(){return this.networkSubsystem.adapters.forEach((e=>{e.disconnect()})),this.flush()}metrics(){return{documents:this.synchronizer.metrics()}}shareConfigChanged(){this.synchronizer.reevaluateDocumentShare()}}class le extends s{peerId;peerMetadata}class me{}const ge=e.Counter,pe=e.RawString,ye=e.RawString,fe=e.getChanges,Se=e.getAllChanges,Ie=e.applyChanges,be=e.view,we=e.getConflicts,ve=e.getCursor,De=e.getCursorPosition,Ee=e.splice,He=e.updateText,Re=e.insertAt,Pe=e.deleteAt,Ce=e.mark,Ae=e.unmark,$e=e.isRawString,Me=e.isRawString,ke=e.getObjectId;export{ge as Counter,M as DocHandle,ye as ImmutableString,le as NetworkAdapter,pe as RawString,ue as Repo,me as StorageAdapter,Ie as applyChanges,R as cbor,D as decodeHeads,Pe as deleteAt,b as documentIdToBinary,v as encodeHeads,I as generateAutomergeUrl,Se as getAllChanges,fe as getChanges,we as getConflicts,ve as getCursor,De as getCursorPosition,ke as getObjectId,Re as insertAt,E as interpretAsDocumentId,Me as isImmutableString,$e as isRawString,V as isRepoMessage,f as isValidAutomergeUrl,S as isValidDocumentId,Ce as mark,p as parseAutomergeUrl,Ee as splice,y as stringifyAutomergeUrl,Ae as unmark,He as updateText,be as view};export default null;
//# sourceMappingURL=/sm/a7ae6f049f237e2270bf51564db7929611e68b937279e6739b0b0e940d29c308.map