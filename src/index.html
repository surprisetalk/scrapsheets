<!DOCTYPE html>
<html lang="en">
  <head>
    <title>scrapsheets</title>
    <meta charset="UTF-8" />
    <meta name="author" content="Taylor Troesh" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="light" />
    <link href="/style.css" rel="stylesheet" />
    <script src="/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/alasql@4"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap");
    </style>
  </head>
  <body>
    <div id="elm"></div>
    <script type="importmap">
      {
        "imports": {
          "@automerge/automerge": "https://esm.sh/@automerge/automerge@3.2.3/slim?bundle-deps",
          "@automerge/automerge/slim": "https://esm.sh/@automerge/automerge@3.2.3/slim?bundle-deps",
          "@automerge/automerge-repo": "https://esm.sh/@automerge/automerge-repo@2.5.1?bundle-deps&external=@automerge/automerge",
          "@automerge/automerge-repo/slim": "https://esm.sh/@automerge/automerge-repo@2.5.1?bundle-deps&external=@automerge/automerge"
        }
      }
    </script>
    <script type="module">
      // Initialize Automerge WASM first
      import { initializeWasm } from "@automerge/automerge";
      await initializeWasm(fetch("/automerge.wasm"));

      // Import Automerge packages
      import { Repo } from "@automerge/automerge-repo";
      import { IndexedDBStorageAdapter } from "https://esm.sh/@automerge/automerge-repo-storage-indexeddb@2.5.1?bundle-deps&external=@automerge/automerge,@automerge/automerge-repo";
      import { BrowserWebSocketClientAdapter } from "https://esm.sh/@automerge/automerge-repo-network-websocket@2.5.1?bundle-deps&external=@automerge/automerge,@automerge/automerge-repo";

      function debounce(func, timeout = 300) {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => {
            func.apply(this, args);
          }, timeout);
        };
      }

      try {
        const app = Elm.Main.init({
          node: document.getElementById("elm"),
          flags: {},
        });

        // Debug logging - set localStorage.debug = 'scrapsheets' to enable verbose logging
        const VERBOSE = localStorage.getItem('debug')?.includes('scrapsheets');
        const debug = {
          log: VERBOSE ? (...args) => console.log('[scrapsheets]', ...args) : () => {},
          error: (...args) => console.error('[scrapsheets]', ...args),
          warn: (...args) => console.warn('[scrapsheets]', ...args),
        };

        function catchy(func, context = 'unknown') {
          return (...args) => {
            try {
              return func.apply(this, args)?.catch((error) => {
                debug.error(`Error in ${context}:`, error);
                app.ports.docErrored.send(
                  `[${context}] ${error?.message ?? "Something went wrong."}`,
                );
              });
            } catch (error) {
              debug.error(`Sync error in ${context}:`, error);
              app.ports.docErrored.send(
                `[${context}] ${error?.message ?? "Something went wrong."}`,
              );
            }
          };
        }

        const Col = (val, key) => {
          const [name, type] = val.split("::");
          return {
            name: name,
            type: type ?? "text",
            key: key.toString(),
          };
        };

        const Table = (cols, ...rows) => ({
          type: "table",
          data: [cols, ...rows],
        });

        const QuerySql = (cols, code, ...examples) => ({
          type: "query",
          data: [
            {
              lang: "sql",
              code,
              cols,
              args: {},
              examples,
            },
          ],
        });

        const Library = {
          get: () => {
            return {
              ...JSON.parse(
                localStorage.getItem("scrapsheets-library") ?? "{}",
              ),
              "": {
                name: "library",
                system: true,
                doc: { type: "library" },
              },
              shop: {
                name: "shop",
                system: true,
                doc: { type: "shop" },
              },
              "portal:time": {
                name: "time demo",
                system: true,
                doc: {
                  type: "portal",
                  data: null,
                },
              },
              "portal:stonks": {
                name: "stonks demo",
                system: true,
                doc: {
                  type: "portal",
                  data: null,
                },
              },
              "portal:dice": {
                name: "dice demo",
                system: true,
                doc: {
                  type: "portal",
                  data: null,
                },
              },
              "portal:orbit": {
                name: "orbit demo",
                system: true,
                doc: {
                  type: "portal",
                  data: null,
                },
              },
              "portal:cafe": {
                name: "cafe demo",
                system: true,
                doc: {
                  type: "portal",
                  data: null,
                },
              },
              "portal:forest": {
                name: "forest demo",
                system: true,
                doc: {
                  type: "portal",
                  data: null,
                },
              },
              "portal:words": {
                name: "words demo",
                system: true,
                doc: {
                  type: "portal",
                  data: null,
                },
              },
              "table:tutorial": {
                name: "tutorial",
                scratch: true,
                system: true,
                doc: Table(
                  ["text::text", "examples::text"].map(Col),
                  ["chapter 1", []],
                  ["chapter 2", []],
                  ["chapter 3", []],
                ),
              },
            };
          },
          set: (id, info) => {
            for (const i in info) if (info[i] === null) delete info[i];
            const library = JSON.parse(
              localStorage.getItem("scrapsheets-library") ?? "{}",
            );
            localStorage.setItem(
              "scrapsheets-library",
              JSON.stringify({
                ...library,
                [id]: { ...library[id], ...info },
              }),
            );
            app.ports.librarySynced.send(Library.get());
          },
          delete: (id) => {
            const library = JSON.parse(
              localStorage.getItem("scrapsheets-library") ?? "{}",
            );
            localStorage.setItem(
              "scrapsheets-library",
              JSON.stringify({ ...library, [id]: undefined }),
            );
            app.ports.librarySynced.send(Library.get());
          },
        };
        app.ports.librarySynced.send(Library.get());

        app.ports.deleteDoc.subscribe(async (id) => Library.delete(id));

        app.ports.updateLibrary.subscribe(({ id, data }) => Library.set(id, data));

        // Query editor autocomplete
        const setupQueryEditorTracking = () => {
          const codeEditor = document.getElementById('code');
          if (!codeEditor) return;

          // Track cursor position on input and selection change
          const reportState = () => {
            if (!app.ports.queryEditorState) return;
            const cursorPos = codeEditor.selectionStart;
            const textBeforeCursor = codeEditor.value.substring(0, cursorPos);
            app.ports.queryEditorState.send({ cursorPos, textBeforeCursor });
          };

          codeEditor.addEventListener('input', reportState);
          codeEditor.addEventListener('click', reportState);
          codeEditor.addEventListener('keyup', (e) => {
            // Report on arrow keys and other navigation
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End'].includes(e.key)) {
              reportState();
            }
          });

          // Handle autocomplete keyboard navigation
          codeEditor.addEventListener('keydown', (e) => {
            // Check if autocomplete is showing (hacky but works)
            const dropdown = document.querySelector('[style*="z-index: 100"]');
            if (!dropdown) return;

            if (e.key === 'ArrowDown') {
              e.preventDefault();
              app.ports.queryEditorState.send({ cursorPos: -1, textBeforeCursor: '__NAV_DOWN__' });
            } else if (e.key === 'ArrowUp') {
              e.preventDefault();
              app.ports.queryEditorState.send({ cursorPos: -2, textBeforeCursor: '__NAV_UP__' });
            } else if (e.key === 'Enter' || e.key === 'Tab') {
              e.preventDefault();
              app.ports.queryEditorState.send({ cursorPos: -3, textBeforeCursor: '__SELECT__' });
            } else if (e.key === 'Escape') {
              e.preventDefault();
              app.ports.queryEditorState.send({ cursorPos: -4, textBeforeCursor: '__CLOSE__' });
            }
          });
        };

        // Insert text at cursor in query editor
        app.ports.insertAtCursor.subscribe((text) => {
          const codeEditor = document.getElementById('code');
          if (!codeEditor) return;

          const start = codeEditor.selectionStart;
          const end = codeEditor.selectionEnd;
          const value = codeEditor.value;

          codeEditor.value = value.substring(0, start) + text + value.substring(end);
          codeEditor.selectionStart = codeEditor.selectionEnd = start + text.length;
          codeEditor.focus();

          // Trigger input event so Elm gets the updated value
          codeEditor.dispatchEvent(new Event('input', { bubbles: true }));
        });

        // Re-setup editor tracking when DOM changes (e.g., navigating to a query)
        const observer = new MutationObserver(() => {
          if (document.getElementById('code')) {
            setupQueryEditorTracking();
          }
        });
        observer.observe(document.body, { childList: true, subtree: true });

        // Clipboard handling
        app.ports.copyToClipboard.subscribe(async (text) => {
          try {
            await navigator.clipboard.writeText(text);
            debug.log('Copied to clipboard:', text.substring(0, 50) + '...');
          } catch (err) {
            debug.error('Failed to copy:', err);
          }
        });

        // Listen for paste events and send to Elm
        document.addEventListener('paste', (e) => {
          // Don't intercept paste when typing in an input
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
          }
          e.preventDefault();
          const text = e.clipboardData.getData('text/plain');
          if (text && app.ports.pasteFromClipboard) {
            app.ports.pasteFromClipboard.send(text);
          }
        });

        // Listen for copy events
        document.addEventListener('copy', (e) => {
          // Don't intercept copy when selecting text in an input
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
          }
          // The actual copy is triggered via port, so we just let Elm know
          if (app.ports.requestCopy) {
            e.preventDefault();
            app.ports.requestCopy.send(null);
          }
        });

        {
          // Initialize the Automerge Repo with storage and network adapters
          const getAuthToken = () => {
            try {
              const userData = JSON.parse(
                localStorage.getItem("scrapsheets-user") || "{}",
              );
              return userData.jwt || null;
            } catch {
              return null;
            }
          };

          // Register a document with the server, retrying on 404 (sync timing)
          async function registerDocWithRetry(id, name) {
            const token = getAuthToken();
            if (!token) return true; // No auth, skip registration

            for (let attempt = 0; attempt < 5; attempt++) {
              if (attempt > 0) {
                await new Promise(r => setTimeout(r, 100 * Math.pow(2, attempt)));
              }
              const res = await fetch(`https://api.sheets.scrap.land/library/${id}`, {
                method: "PUT",
                headers: {
                  "Content-Type": "application/json",
                  "Authorization": `Bearer ${token}`,
                },
                body: JSON.stringify({ name: name ?? "", tags: [] }),
              });
              if (res.ok) return true;
              if (res.status !== 404) break; // Only retry on 404 (sync timing)
            }
            return false;
          }

          const token = getAuthToken();
          const syncUrl =
            "wss://api.sheets.scrap.land/library/sync" +
            (token ? `?auth=Bearer%20${encodeURIComponent(token)}` : "");

          // Track sync connection status
          const syncStatus = {
            connected: false,
            lastError: null,
            attempts: 0,
          };

          debug.log('Initializing repo with sync URL:', syncUrl);
          const networkAdapter = new BrowserWebSocketClientAdapter(syncUrl);

          const repo = new Repo({
            storage: new IndexedDBStorageAdapter(),
            network: [networkAdapter],
          });

          // Log repo events if available
          if (repo.on) {
            repo.on('document', ({ handle }) => {
              debug.log('Repo received document:', handle.documentId);
            });
          }

          // Expose debug info globally for console access
          window.__scrapsheets = {
            repo,
            syncStatus,
            Library,
            getDocState: (id) => {
              const [type, doc_id] = id.split(':');
              const inLibrary = Library.get()[id];
              return {
                id,
                type,
                doc_id,
                inLibrary: !!inLibrary,
                libraryEntry: inLibrary,
                repoHandles: repo.handles ? Object.keys(repo.handles) : 'N/A',
              };
            },
          };

          let sheet;

          const setupDragDrop = () => {
            document.body.addEventListener("dragover", (e) => {
              e.preventDefault();
              e.stopPropagation();
              e.dataTransfer.dropEffect = "copy";
              document.body.classList.add("drag-over");
            });
            document.body.addEventListener("dragleave", (e) => {
              e.preventDefault();
              e.stopPropagation();
              document.body.classList.remove("drag-over");
            });
            document.body.addEventListener("drop", async (e) => {
              e.preventDefault();
              e.stopPropagation();
              document.body.classList.remove("drag-over");
              const files = Array.from(e.dataTransfer.files).filter(
                (file) =>
                  file.type === "text/csv" ||
                  file.name.endsWith(".csv"),
              );
              for (const file of files) {
                try {
                  const lines = (await file.text())
                    .split("\n")
                    .filter((line) => line.trim());
                  if (!lines.length) return null;
                  const [headers, ...data] = lines.map((row) => {
                    const result = [];
                    let current = "";
                    let inQuotes = false;
                    for (let i = 0; i < row.length; i++) {
                      const char = row[i];
                      if (char === '"') {
                        if (inQuotes && row[i + 1] === '"') {
                          current += '"';
                          i++;
                        } else {
                          inQuotes = !inQuotes;
                        }
                      } else if (char === "," && !inQuotes) {
                        result.push(current.trim());
                        current = "";
                      } else {
                        current += char;
                      }
                    }
                    result.push(current.trim());
                    return result;
                  });
                  if (!headers.length) return;
                  const newSheet = repo.create({
                    type: "table",
                    data: [
                      headers.map((name, key) => ({
                        name,
                        type: "text",
                        key,
                      })),
                      ...data.map((row) => {
                        const rowObj = {};
                        headers.forEach((header, index) => {
                          rowObj[index] = row[index] || "";
                        });
                        return rowObj;
                      }),
                    ],
                  });
                  const id = `table:${newSheet.documentId}`;
                  const csvName = file.name.replace(/\.csv$/i, "");
                  Library.set(id, { name: csvName, tags: [] });

                  // Register document in database with retry for sync timing
                  const registered = await registerDocWithRetry(id, csvName);
                  if (!registered) {
                    console.error("Failed to register CSV document after retries");
                    app.ports.docErrored.send("Failed to save imported file. Please try again.");
                    return;
                  }

                  requestAnimationFrame(() => {
                    window.location = `/${id}`;
                  });
                } catch (error) {
                  console.error("Error processing CSV file:", error);
                  app.ports.docErrored.send(
                    `Error processing ${file.name}: ${error.message}`,
                  );
                }
              }
            });
          };
          if (document.readyState === "loading") {
            document.addEventListener(
              "DOMContentLoaded",
              setupDragDrop,
            );
          } else { setupDragDrop(); }

          alasql.options.modifier = "RECORDSET";
          for (
            const type of [
              "image",
              "link",
              "usd",
              "percentage",
              "date",
              "int",
              "float",
            ]
          ) {
            alasql.fn[type] = (data) => ({ type, data });
          }
          alasql.from.SHEET = (id, params = {}) => {
            // TODO: Grab sheet (e.g. portal) with given params.
            throw new Error("TODO");
          };
          alasql.fn.http = (url, qs = {}) => {
            const atomToJson = (xmlString) => {
              const parser = new DOMParser();
              const doc = parser.parseFromString(xmlString, "text/xml");
              const feed = {
                title: doc.querySelector("feed > title")?.textContent,
                updated: doc.querySelector("feed > updated")
                  ?.textContent,
                totalResults: parseInt(
                  doc.querySelector("totalResults")?.textContent || "0",
                ),
                entries: [],
              };
              doc.querySelectorAll("entry").forEach((entry) => {
                feed.entries.push({
                  id: entry.querySelector("id")?.textContent,
                  title: entry.querySelector("title")?.textContent
                    ?.trim(),
                  summary: entry.querySelector("summary")?.textContent
                    ?.trim(),
                  published: entry.querySelector("published")
                    ?.textContent,
                  updated: entry.querySelector("updated")?.textContent,
                  authors: Array.from(
                    entry.querySelectorAll("author name"),
                  ).map((a) => a.textContent),
                  links: Array.from(entry.querySelectorAll("link")).map(
                    (l) => ({
                      href: l.getAttribute("href"),
                      rel: l.getAttribute("rel"),
                      type: l.getAttribute("type"),
                    }),
                  ),
                  categories: Array.from(
                    entry.querySelectorAll("category"),
                  ).map((c) => c.getAttribute("term")),
                });
              });
              return feed;
            };
            const parsers = {
              "application/atom+xml": atomToJson,
            };
            if (!url) return;
            // Route external URLs through proxy to avoid CORS issues
            const apiBase = "https://api.sheets.scrap.land";
            const isExternal = !url.startsWith(window.location.origin) && !url.startsWith(apiBase);
            const targetUrl = isExternal
              ? `${apiBase}/proxy?url=${encodeURIComponent(url + "?" + new URLSearchParams(qs))}`
              : url + "?" + new URLSearchParams(qs);
            const request = new XMLHttpRequest();
            request.open(
              "GET",
              targetUrl,
              false,
            ); // `false` makes the request synchronous
            request.send(null);
            return {
              status: request.status,
              res: (
                parsers?.[
                  request
                    .getResponseHeader("Content-Type")
                    ?.replace(/;.*$/, "") || "application/json"
                ] ?? JSON.parse
              )?.(request.responseText) || null,
            };
          };
          alasql.from.HTTP = (url, qs = {}) => {
            const { status, res } = alasql.fn.http(url, qs);
            if (status >= 400) {
              const msg = res?.error || `HTTP ${status}`;
              throw new Error(`Failed to fetch data: ${msg}`);
            }
            return res;
          };
          // Parse SQL error to extract position info
          const parseQueryError = (error, code) => {
            const msg = error?.message || String(error);
            const lines = code.split('\n');

            // Try to extract line/column from common error patterns
            // AlaSQL: "Parse error on line X"
            const lineMatch = msg.match(/line\s+(\d+)/i);
            // Position in string
            const posMatch = msg.match(/position\s+(\d+)/i);

            let lineNum = null;
            let colNum = null;
            let context = null;

            if (lineMatch) {
              lineNum = parseInt(lineMatch[1], 10);
            }

            if (posMatch && !lineNum) {
              // Convert position to line/column
              const pos = parseInt(posMatch[1], 10);
              let charCount = 0;
              for (let i = 0; i < lines.length; i++) {
                if (charCount + lines[i].length >= pos) {
                  lineNum = i + 1;
                  colNum = pos - charCount;
                  break;
                }
                charCount += lines[i].length + 1; // +1 for newline
              }
            }

            // Add context (the offending line)
            if (lineNum && lineNum <= lines.length) {
              context = lines[lineNum - 1];
            }

            // Format error message with line info
            let formatted = msg;
            if (lineNum) {
              formatted = `Line ${lineNum}${colNum ? `:${colNum}` : ''}: ${msg}`;
              if (context) {
                formatted += `\n\n  ${lineNum} │ ${context}`;
                if (colNum) {
                  formatted += `\n    │ ${' '.repeat(colNum - 1)}^`;
                }
              }
            }

            return formatted;
          };

          const queryDoc = debounce(
            async (id, { code, lang, args, cols: cols_ = {} }) => {
              try {
                switch (lang) {
                  case "sql":
                    // TODO: Run alasql if possible, otherwise post to /query.
                    const params = new URLSearchParams(window.location.search)
                      .get("q")
                      ?.split(/\s+(?=\w+=)/)
                      .reduce(
                        (r, p) => {
                          const [k, v] = p.includes("=") ? p.split("=") : ["", p];
                          return ((r[k] ||= []).push(v), r);
                        },
                        { "": [].join(" ") },
                      ) ?? { "": null };
                    const [, { columns: cols, data: rows } = {}] = await alasql([
                      [`set @params = ?`, [params]],
                      code,
                    ]);
                    // TODO: If doc contains cols data, use that names and types.
                    app.ports.docQueried.send({
                      id,
                      data: [
                        cols.map((col) => ({
                          key: col.columnid,
                          name: col.columnid,
                          type: cols_?.[col.columnid] ?? null,
                        })),
                        ...rows,
                      ],
                    });
                    break;
                  default:
                    throw new Error(`Unsupported query language: ${lang}`);
                }
              } catch (error) {
                const formatted = parseQueryError(error, code);
                app.ports.docErrored.send(formatted);
              }
            },
            300,
          );
          app.ports.queryDoc.subscribe(({ id, data }) => queryDoc(id, data));

          let ws;
          const selectDoc = catchy(async (id, sheetHandle) => {
            const [type, doc_id] = id.split(":");
            debug.log('selectDoc:', id);

            const libraryEntry = Library.get()[id];
            const doc = libraryEntry?.doc ?? sheetHandle?.doc?.();

            if (!doc) {
              if (type && doc_id) {
                // User-friendly error with collapsible details
                const details = [
                  `In library: ${!!libraryEntry}`,
                  `Handle exists: ${!!sheetHandle}`,
                  `Handle state: ${sheetHandle?.state ?? 'N/A'}`,
                ].join(' | ');
                return app.ports.docErrored.send(
                  `Could not load this document. It may have been deleted or not yet synced.\n\nTry refreshing the page.\n\n[Details: ${details}]`
                );
              }
              return app.ports.docSelected.send({
                id: "",
                data: { doc: { type: "library" } },
              });
            }

            debug.log('Loaded:', id);
            app.ports.docSelected.send({
              id,
              data: { doc: doc && { ...doc } },
            });
            if (!type || !doc_id) return;
            if (type === "query") queryDoc(id, doc.data[0]);
            sheetHandle?.on?.("change", (data) => {
              app.ports.docChanged.send({
                id: type + ":" + data.handle.documentId,
                data,
              });
              if (type === "query") queryDoc(id, data.doc.data[0]);
            });
            if (type === "portal") {
              const portalUrl = `wss://api.sheets.scrap.land/${type}/${doc_id}/sync`;
              let retries = 0;
              const maxRetries = 5;
              const connect = () => {
                ws = new WebSocket(portalUrl);
                const portalTimeout = setTimeout(() => {
                  app.ports.docErrored.send("Live data connection timed out. Try refreshing.");
                  ws?.close();
                }, 10000);
                ws.onmessage = (msg) => {
                  clearTimeout(portalTimeout);
                  retries = 0;
                  app.ports.docChanged.send({
                    id,
                    data: {
                      doc: JSON.parse(msg.data),
                      handle: null,
                      patchInfo: null,
                      patches: [],
                    },
                  });
                };
                ws.onerror = () => {
                  clearTimeout(portalTimeout);
                };
                ws.onclose = (e) => {
                  clearTimeout(portalTimeout);
                  if (e.code === 1000) return;
                  if (retries < maxRetries) {
                    const delay = Math.min(1000 * 2 ** retries, 30000);
                    retries++;
                    setTimeout(connect, delay);
                  } else {
                    app.ports.docErrored.send("Live data connection lost.");
                  }
                };
              };
              connect();
            }
          }, 'selectDoc');

          const changeId = catchy(async (id) => {
            const [type, doc_id = ""] = id.split(":");
            if (doc_id === sheet?.documentId) return;
            ws?.close?.();

            debug.log('changeId:', id);

            if (!doc_id) {
              sheet = null;
              await selectDoc(id, null);
              return;
            }

            // Find document in repo with retry logic
            const findWithTimeout = async (retries = 2) => {
              for (let attempt = 0; attempt < retries; attempt++) {
                try {
                  const handle = await repo?.find(doc_id);
                  if (handle?.whenReady) {
                    await Promise.race([
                      handle.whenReady(),
                      new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 10000)),
                    ]);
                  }
                  return handle;
                } catch (err) {
                  debug.warn(`repo.find attempt ${attempt + 1} failed:`, err.message);
                  if (attempt < retries - 1) {
                    await new Promise(r => setTimeout(r, 1000)); // Wait 1s before retry
                  }
                }
              }
              return null;
            };
            try {
              sheet = await findWithTimeout();
            } catch (err) {
              debug.warn('repo.find failed:', err.message);
              sheet = null;
            }

            await selectDoc(id, sheet);
          }, 'changeId');
          app.ports.changeId.subscribe(changeId);
          changeId(window.location.pathname.slice(1));

          app.ports.newDoc.subscribe(
            catchy(async ({ name, type, data }) => {
              debug.log('newDoc:', { type, name });

              if (!repo) {
                app.ports.docErrored.send('Sync not initialized. Please refresh.');
                return;
              }

              // Create document and wait for it to be ready
              sheet = repo.create({ type, data });
              if (!sheet) {
                app.ports.docErrored.send('Failed to create document.');
                return;
              }

              const id = `${type}:${sheet.documentId}`;
              debug.log('Created:', id);

              if (sheet.whenReady) {
                await sheet.whenReady();
              }

              // Save to localStorage and register with server
              Library.set(id, { name: name ?? "", tags: [] });
              await registerDocWithRetry(id, name);

              // Load document without page reload (key fix: keeps sheet handle in memory)
              window.history.pushState({}, '', `/${id}`);
              await selectDoc(id, sheet);
            }, 'newDoc'),
          );

          app.ports.importCsv.subscribe(
            catchy(async ({ filename, content }) => {
              debug.log('importCsv:', filename);
              const token = getAuthToken();
              if (!token) {
                app.ports.docErrored.send('Please log in to import CSV files.');
                return;
              }
              try {
                const formData = new FormData();
                formData.append('filename', filename);
                formData.append('content', content);
                const res = await fetch('https://api.sheets.scrap.land/import/csv', {
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${token}`,
                  },
                  body: formData,
                });
                if (!res.ok) {
                  const text = await res.text();
                  app.ports.docErrored.send(`CSV import failed: ${text || res.statusText}`);
                  return;
                }
                // Refresh library to show the new sheet
                await changeId('');
              } catch (err) {
                app.ports.docErrored.send(`CSV import failed: ${err?.message ?? 'Unknown error'}`);
              }
            }, 'importCsv'),
          );

          app.ports.changeDoc.subscribe(
            catchy(async ({ id, data: patches }) => {
              const [type, doc_id] = id.split(":");
              {
                const doc = Library.get()[id]?.doc;
                if (doc) {
                  const d = { ...doc };
                  for (const { path, action, value } of patches) {
                    switch (path.length) {
                      case 0: {
                        if (action === "push") d.data.push(...value);
                        else if (action === "splice") d.data.splice(...value);
                        break;
                      }
                      case 1: {
                        const [y] = path;
                        if (action === "set") d.data[y] = value;
                        else if (action === "push") d.data[y].push(...value);
                        else if (action === "splice") d.data[y].splice(...value);
                        break;
                      }
                      case 2: {
                        const [y, x] = path;
                        if (!d.data[y]) d.data[y] = {};
                        if (action === "set") d.data[y][x] = value;
                        else if (action === "del") delete d.data[y][x];
                        else d.data[y][x][action](...value);
                        break;
                      }
                      default:
                        throw new Error("TODO: path");
                    }
                  }
                  app.ports.docChanged.send({
                    id,
                    data: {
                      doc: d,
                      handle: null,
                      patchInfo: null,
                      patches: [],
                    },
                  });
                  if (type === "query") queryDoc(id, d.data[0]);
                  return;
                }
              }
              sheet?.change((d) => {
                for (const { path, action, value } of patches) {
                  switch (path.length) {
                    case 0: {
                      d.data[action](...value);
                      break;
                    }
                    case 1: {
                      const [y] = path;
                      if (action === "set") d.data[y] = value;
                      else d.data[y][action](...value);
                      break;
                    }
                    case 2: {
                      const [y, x] = path;
                      if (!d.data[y]) d.data[y] = {};
                      if (action === "set") d.data[y][x] = value;
                      else if (action === "del") delete d.data[y][x];
                      else d.data[y][x][action](...value);
                      break;
                    }
                    default:
                      throw new Error("TODO: path");
                  }
                }
              });
            }, 'changeDoc'),
          );
        }
      } catch (error) {
        console.error('[scrapsheets] Fatal initialization error:', error);
        app.ports.docErrored.send(
          `Initialization failed: ${error?.message ?? "Something went wrong."}`,
        );
      }
    </script>
  </body>
</html>
