<!doctype html>
<html lang="en">
  <head>
    <title>scrapsheets</title>
    <meta charset="UTF-8" />
    <meta name="author" content="Taylor Troesh" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="dark light" />
    <meta
      name="theme-color"
      content="#ffffff"
      media="(prefers-color-scheme: light)" />
    <meta
      name="theme-color"
      content="#151515"
      media="(prefers-color-scheme: dark)" />
    <link href="/style.css" rel="stylesheet" />
    <script src="/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/alasql@4"></script>
  </head>
  <body>
    <div id="elm"></div>
    <script type="module">
      import * as AM from "/automerge.js";

      function debounce(func, timeout = 300) {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => {
            func.apply(this, args);
          }, timeout);
        };
      }

      try {
        const app = Elm.Main.init({
          node: document.getElementById("elm"),
          flags: {},
        });

        function catchy(func) {
          return (...args) => {
            try {
              return func.apply(this, args)?.catch(error => {
                console.error(error);
                app.ports.docErrored.send(
                  error?.message ?? "Something went wrong.",
                );
              });
            } catch (error) {
              console.error(error);
              app.ports.docErrored.send(
                error?.message ?? "Something went wrong.",
              );
            }
          };
        }

        const Col = (val, key) => {
          const [name, type] = val.split("::");
          return {
            name: name,
            type: type ?? "string",
            key: key.toString(),
          };
        };

        const Template = (name, type, data) => ({
          type: "template",
          data: [{ type, data }],
        });

        const Scratch = data => ({
          type: "scratch",
          data: [data],
        });

        const Table = (cols, ...rows) => ({
          type: "table",
          data: [cols, ...rows],
        });

        const Library = {
          get: () => {
            const examples = {
              "scratch-table:calculated-columns": Table(
                [
                  { key: 0, name: "a", type: "int" },
                  { key: 1, name: "b", type: "int" },
                  {
                    key: 2,
                    name: "c",
                    type: { lang: "formula", code: "a + b" },
                  },
                ],
                ...[
                  [1, 2],
                  [2, 4],
                  [3, 6],
                ],
              ),
              "scratch-table:postman": Table(
                [
                  { key: 0, name: "method", type: "text" },
                  { key: 1, name: "url", type: "text" },
                  { key: 2, name: "fields", type: "list field" },
                  {
                    key: 3,
                    name: "form",
                    type: {
                      lang: "scrapscript",
                      code: "form {method,url,fields}",
                    },
                  },
                ],
                ...[
                  [
                    "GET",
                    "example.com/foo",
                    [
                      { label: "hello", type: "text" },
                      { label: "world", type: "date" },
                    ],
                  ],
                  [
                    "POST",
                    "example.com/bar",
                    [
                      {
                        label: "my dropdown",
                        key: "my_dropdown",
                        type: { 1: "label a", 2: "label b" },
                        default: 2,
                      },
                    ],
                  ],
                ],
              ),
              "scratch-table:nested": Table(
                [
                  { key: 0, name: "a", type: "list string" },
                  { key: 1, name: "b", type: "dict string string" },
                  { key: 1, name: "c", type: "dict string (list string)" },
                ],
                ...[
                  [
                    ["a", "b"],
                    { c: "d", e: "f" },
                    { g: ["h", "i"], j: ["k", "l", "m"] },
                  ],
                  [["n"], { o: "p" }, { q: [], r: ["s", "t"] }],
                ],
              ),
              "scratch-query:http-get": {
                type: "query",
                data: [
                  {
                    lang: "sql",
                    code: "select * from http('https://taylor.town/random')",
                    args: {},
                    examples: [],
                  },
                ],
              },
              "scratch-query:python": {
                type: "query",
                data: [
                  {
                    lang: "python",
                    code: "return [[{'name':'a','type':'text','key':'a'}], {'a':1}, {'a':2}, {'a':3}]",
                    args: {},
                    examples: [],
                  },
                ],
              },
              "scratch-query:stonks": {
                type: "query",
                data: [
                  {
                    lang: "sql",
                    code: "select stonks->>'id', stonks->>'price' from http('https://taylor.town/stonks'), json(res) stonks",
                    args: {},
                    examples: [],
                  },
                ],
              },
              // TODO: Move these to the shop.
              ...{
                "scratch-query:bluesky-actors": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select * from @(http('https://public.api.bsky.app/xrpc/app.bsky.actor.searchActors', @{q:coalesce(@params->(''),'taylor.town')})->res->actors)",
                      args: {},
                      examples: ["taylor.town", "memes"],
                    },
                  ],
                },
                "scratch-query:github-repos": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select full_name, description, stargazers_count, language, open_issues_count, license from @(http('https://api.github.com/search/repositories', @{q:coalesce(@params->(''),'surprisetalk')})->res->items)",
                      args: { q: "text" },
                      examples: [
                        "scrapscript sort=stars",
                        "surprisetalk sort=updated",
                        "jquery in:name,description",
                        "jquery in:readme ",
                        "repo:octocat/hello-world",
                        "user:surprisetalk forks:>100 ",
                        "org:scrapscript",
                        "size:>=30000",
                        "size:<50",
                        "size:50..120",
                        "node followers:>=10000",
                        "stars:>=500 language:php",
                        "css pushed:>2013-02-01",
                        "webos created:<2011-01-01",
                        "rails language:javascript",
                        "license:apache-2.0",
                        "archived:true GNOME",
                        "help-wanted-issues:>n",
                        "good-first-issues:>n",
                        "is:sponsorable",
                      ],
                    },
                  ],
                },
                "scratch-query:github-users": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select * from @(http('https://api.github.com/search/users', @{q:(@params->(''))})->res->items)",
                      args: { q: "text" },
                      examples: [
                        "surprisetalk sort=followers",
                        "foo sort=joined",
                        "mike in:name created:<2011-01-01 type:user",
                        "data in:email type:org",
                        "user:octocat",
                        "org:electron type:user",
                        "kenya in:login",
                        "bolton in:name",
                        "fullname:nat friedman",
                        "data in:email",
                        "repos:>9000",
                        "repos:1 location:iceland",
                        "language:javascript location:russia",
                        "jenny language:javascript in:fullname",
                        "created:2010-01-01..2011-01-01 john in:login",
                        "followers:>=1000",
                        "is:sponsorable",
                      ],
                    },
                  ],
                },
                "scratch-query:github-commits": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select * from @(http('https://api.github.com/search/commits', @{q:(@params->(''))})->res->items)",
                      args: { q: "text" },
                      examples: ["repo:tekknolagi/scrapscript", "surprisetalk"],
                    },
                  ],
                },
                "scratch-query:github-prs-issues": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select * from @(http('https://api.github.com/search/issues', @{q:(@params->(''))})->res->items)",
                      args: { q: "text" },
                      examples: [
                        "repo:tekknolagi/scrapscript",
                        "user:surprisetalk",
                        "author:surprisetalk",
                        "assignee:surprisetalk",
                        "commenter:surprisetalk",
                        "language:ruby",
                        "state:closed comments:>100",
                        "draft:true",
                        "interactions:>2000",
                        "reactions:>1000",
                        "archived:false gnome",
                        "gnome is:unmerged",
                        "language:javascript merged:<2011-01-01",
                        "language:c# created:<2011-01-01 state:open",
                        "type:pr review-requested:benbalter",
                        "type:pr reviewed-by:gjtorikian",
                        "type:pr review:changes_requested",
                        "mentions:surprisetalk",
                        "team:example/example",
                        "bug type:issue sort=reactions-+1",
                        "type:pr sort=comments",
                        "oops in:title,body,comments",
                        "state:open",
                        "sort=reactions-smile",
                        "sort=updated",
                      ],
                    },
                  ],
                },
                "scratch-query:crypto-markets": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select * from @(http('https://api.coingecko.com/api/v3/coins/markets', @{vs_currency:'usd', `order`:'market_cap_desc', per_page:100})->res)",
                      args: {},
                      examples: [],
                    },
                  ],
                },
                "scratch-query:crypto-search": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select thumb::img as thumb, symbol, name, market_cap_rank from @(http('https://api.coingecko.com/api/v3/search', @{`query`:(@params->(''))})->res->coins)",
                      args: {},
                      examples: ["bitcoin", "ethereum", "doge"],
                    },
                  ],
                },
                "scratch-query:hackernews-search": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select * from @(http('https://hn.algolia.com/api/v1/search', @{`query`:(@params->(''))})->res->hits)",
                      args: {},
                      examples: ["taylor.town"],
                    },
                  ],
                },
                "scratch-query:hackernews-top": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select * from @(http('https://corsproxy.io/?url=https://hnrss.org/frontpage.jsonfeed')->res->items)",
                      args: {},
                      examples: [],
                    },
                  ],
                },
                "scratch-query:arxiv-search": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select * from @(http('https://export.arxiv.org/api/query', @{search_query:('all:' || (@params->(''))), max_results:25})->res->entries)",
                      args: {},
                      examples: [],
                    },
                  ],
                },
                /*
                "scratch-query:wikipedia-search": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select * from @(http('https://en.wikipedia.org/w/api.php', @{action:'opensearch', search:(@params->('')), limit:10, format:'json'})->res)",
                      args: {},
                      examples: [],
                    },
                  ],
                },
                "scratch-query:reddit-search": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select title, author, score, num_comments, subreddit, url from @(http('https://www.reddit.com/search.json', @{q:(@params->('')), limit:25})->res->data->children->data)",
                      args: {},
                      examples: [],
                    },
                  ],
                },
                "scratch-query:reddit-subreddit": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select title, author, score, num_comments, url from @(http('https://www.reddit.com/r/programming.json', @{limit:25})->res->data->children->data)",
                      args: {},
                      examples: [],
                    },
                  ],
                },
                "scratch-query:manifold-search": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select question, creatorName, probability, volume24Hours, totalLiquidity from @(http('https://api.manifold.markets/v0/search-markets', @{term:(@params->('')), limit:20})->res)",
                      args: {},
                      examples: [],
                    },
                  ],
                },

                "scratch-query:manifold-trending": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select question, creatorName, probability, volume24Hours from @(http('https://api.manifold.markets/v0/markets', @{limit:20, sort:'24-hour-vol'})->res)",
                      args: {},
                      examples: [],
                    },
                  ],
                },
                "scratch-query:fred-search": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select id, title, units, frequency, popularity from @(http('https://api.stlouisfed.org/fred/series/search', @{search_text:(@params->('')), api_key:'YOUR_KEY', file_type:'json'})->res->seriess)",
                      args: {},
                      examples: [],
                    },
                  ],
                },
                "scratch-query:stocks-search": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select symbol, shortname, quoteType, exchange from @(http('https://query1.finance.yahoo.com/v1/finance/search', @{q:(@params->(''))})->res->quotes)",
                      args: {},
                      examples: [],
                    },
                  ],
                },
                "scratch-query:discogs-search": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select title, year, country, genre, style from @(http('https://api.discogs.com/database/search', @{q:(@params->('')), type:'release'})->res->results)",
                      args: {},
                      examples: [],
                    },
                  ],
                },
                "scratch-query:speedrun-games": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select names->international as name, abbreviation, released from @(http('https://www.speedrun.com/api/v1/games', @{name:(@params->(''))})->res->data)",
                      args: {},
                      examples: [],
                    },
                  ],
                },
                "scratch-query:youtube-search": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select snippet->title as title, snippet->channelTitle as channel, snippet->description from @(http('https://www.googleapis.com/youtube/v3/search', @{part:'snippet', q:(@params->('')), key:'YOUR_API_KEY', maxResults:25})->res->items)",
                      args: {},
                      examples: [],
                    },
                  ],
                },
                "scratch-query:podcast-search": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select collectionName, artistName, feedUrl, trackCount, primaryGenreName from @(http('https://itunes.apple.com/search', @{term:(@params->('')), media:'podcast', limit:25})->res->results)",
                      args: {},
                      examples: [],
                    },
                  ],
                },
                "scratch-query:ossinsight-search": {
                  type: "query",
                  data: [
                    {
                      lang: "sql",
                      code: "select repo_name, stars, forks, issues, language from @(http('https://api.ossinsight.io/v1/repos/search', @{keyword:(@params->(''))})->res->data)",
                      args: {},
                      examples: [],
                    },
                  ],
                },
                */
              },
            };
            return {
              ...Object.fromEntries(
                Object.entries(examples).map(([k, v]) => [
                  k,
                  { name: k.split(":").pop(), doc: Scratch(v) },
                ]),
              ),
              ...JSON.parse(
                localStorage.getItem("scrapsheets-library") ?? "{}",
              ),
              "": { name: "library", doc: { type: "library" } },
              // "portal:shop": { name: "shop" },
              "template:table": {
                name: "table",
                doc: Template("table", "table", ["a", "b", "c"].map(Col)),
              },
              "template:query": {
                name: "template",
                doc: Template("query", "query", [
                  {
                    lang: "sql",
                    code: "select 1 as a",
                    args: [],
                    examples: [],
                  },
                ]),
              },
              "table:tutorial": {
                name: "tutorial",
                doc: Table(
                  ["text::text", "examples::text"].map(Col),
                  ["chapter 1", []],
                  ["chapter 2", []],
                  ["chapter 3", []],
                ),
              },
              "table:roadmap": {
                // TODO: Query this from scrapsheets github.
                name: "roadmap",
                doc: Table(
                  ["-::bool", "task::text"].map(Col),
                  [true, "fix scratch queries"],
                  [true, "search args"],
                  [true, "search arg examples"],
                  [true, "nicer errors"],
                  [true, "fix select * from"],
                  [true, "move name/tags edit to library page"],
                  [false, "tons of examples"],
                  [false, "sidebar: share"],
                  [false, "sidebar: stats"],
                  [false, "sidebar: hints"],
                  [false, "sidebar: history"],
                  [false, "sidebar: settings"],
                  [false, "run query button; no debounce?"],
                  [false, "code todos"],
                  [false, "crude styling"],
                  [false, "deploy"],
                  [false, "demo"],
                  [false, "column sorting (update search bar)"],
                  [false, "make editable cells more obvious"],
                ),
              },
              "table:examples": {
                name: "examples",
                doc: Table(
                  ["sheet_id::link", "name::text"].map(Col),
                  ...Object.entries(examples).map(([k, v]) => [
                    k,
                    k.split(":").pop(),
                  ]),
                ),
              },
            };
          },
          set: (id, info) => {
            for (const i in info) if (info[i] === null) delete info[i];
            const library = JSON.parse(
              localStorage.getItem("scrapsheets-library") ?? "{}",
            );
            localStorage.setItem(
              "scrapsheets-library",
              JSON.stringify({ ...library, [id]: { ...library[id], ...info } }),
            );
            app.ports.librarySynced.send(Library.get());
          },
          delete: id => {
            const library = JSON.parse(
              localStorage.getItem("scrapsheets-library") ?? "{}",
            );
            localStorage.setItem(
              "scrapsheets-library",
              JSON.stringify({ ...library, [id]: undefined }),
            );
            app.ports.librarySynced.send(Library.get());
          },
        };
        app.ports.librarySynced.send(Library.get());

        app.ports.deleteDoc.subscribe(async id => Library.delete(id));

        app.ports.updateLibrary.subscribe(({ id, data }) =>
          Library.set(id, data),
        );

        {
          await AM.initializeWasm(fetch("/automerge.wasm"));

          const repo = new AM.Repo({
            storage: new AM.IndexedDBStorageAdapter(),
            // network: [new AM.BrowserWebSocketClientAdapter("wss://sync.automerge.org")],
          });

          let sheet;

          alasql.options.modifier = "RECORDSET";
          alasql.from.SHEET = (id, params = {}) => {
            // TODO: Grab sheet (e.g. portal) with given params.
            throw new Error("TODO");
          };
          alasql.fn.http = (url, qs = {}) => {
            const atomToJson = xmlString => {
              const parser = new DOMParser();
              const doc = parser.parseFromString(xmlString, "text/xml");
              const feed = {
                title: doc.querySelector("feed > title")?.textContent,
                updated: doc.querySelector("feed > updated")?.textContent,
                totalResults: parseInt(
                  doc.querySelector("totalResults")?.textContent || "0",
                ),
                entries: [],
              };
              doc.querySelectorAll("entry").forEach(entry => {
                feed.entries.push({
                  id: entry.querySelector("id")?.textContent,
                  title: entry.querySelector("title")?.textContent?.trim(),
                  summary: entry.querySelector("summary")?.textContent?.trim(),
                  published: entry.querySelector("published")?.textContent,
                  updated: entry.querySelector("updated")?.textContent,
                  authors: Array.from(
                    entry.querySelectorAll("author name"),
                  ).map(a => a.textContent),
                  links: Array.from(entry.querySelectorAll("link")).map(l => ({
                    href: l.getAttribute("href"),
                    rel: l.getAttribute("rel"),
                    type: l.getAttribute("type"),
                  })),
                  categories: Array.from(
                    entry.querySelectorAll("category"),
                  ).map(c => c.getAttribute("term")),
                });
              });
              return feed;
            };
            const parsers = {
              "application/atom+xml": atomToJson,
              "application/json": JSON.parse,
            };
            if (!url) return;
            const request = new XMLHttpRequest();
            try {
              request.open("GET", url + "?" + new URLSearchParams(qs), false); // `false` makes the request synchronous
              request.send(null);
              console.log(
                request
                  .getResponseHeader("Content-Type")
                  ?.replace(/;.*$/, "") || "application/json",
              );
              return {
                status: request.status,
                res:
                  parsers?.[
                    request
                      .getResponseHeader("Content-Type")
                      ?.replace(/;.*$/, "") || "application/json"
                  ]?.(request.responseText) || null,
              };
            } catch (error) {
              console.error(url, qs, request.status, request.responseText);
              console.error(error);
              return { status: request.status, res: null };
            }
          };
          const queryDoc = debounce(
            catchy(async (id, { code, lang, args }) => {
              switch (lang) {
                case "sql":
                  // TODO: Run alasql if possible, otherwise post to /query.
                  const params =
                    new URLSearchParams(window.location.search)
                      .get("q")
                      ?.split(/\s+(?=\w+=)/)
                      .reduce(
                        (r, p) => {
                          const [k, v] = p.includes("=")
                            ? p.split("=")
                            : ["", p];
                          return ((r[k] ||= []).push(v), r);
                        },
                        { "": [].join(" ") },
                      ) ?? {};
                  const [, { columns: cols, data: rows } = {}] =
                    alasql(`set @params = ?; ${code}`, [params]) || [];
                  app.ports.docQueried.send({
                    id,
                    data: [
                      cols.map(col => ({
                        name: col.columnid,
                        key: col.columnid,
                        type: "text",
                      })),
                      ...rows,
                    ],
                  });
                  break;
                default:
                  throw new Error(`TODO: ${lang}`);
              }
            }),
            300,
          );
          app.ports.queryDoc.subscribe(({ id, data }) => queryDoc(id, data));

          const selectDoc = catchy(async (id, sheet) => {
            const [type, doc_id] = id.split(":");
            const doc = Library.get()[id]?.doc ?? sheet?.doc?.();
            app.ports.docSelected.send({
              id,
              data: { doc: doc && { ...doc } },
            });
            if (type === "query") queryDoc(id, doc.data[0]);
            if (type === "scratch-query") queryDoc(id, doc.data[0].data[0]);
            sheet?.on?.("change", data => {
              app.ports.docChanged.send({
                id: type + ":" + data.handle.documentId,
                data,
              });
              if (type === "query") queryDoc(id, data.doc.data[0]);
            });
          });

          const changeId = catchy(async id => {
            const [, doc_id = ""] = id.split(":");
            if (doc_id === sheet?.documentId) return;
            // TODO: Remove existing listeners.
            sheet = await repo?.find(doc_id).catch(() => null);
            await selectDoc(id, sheet);
          });
          app.ports.changeId.subscribe(changeId);
          changeId(window.location.pathname.slice(1));

          app.ports.newDoc.subscribe(
            catchy(async ({ type, data }) => {
              // TODO: Remove existing listeners.
              sheet = repo?.create({ type, data });
              const id = `${type}:${sheet.documentId}`;
              Library.set(id, { name: "", tags: [] });
              await selectDoc(id, sheet);
            }),
          );

          app.ports.changeDoc.subscribe(
            catchy(async ({ id, data: patches }) => {
              const [type, doc_id] = id.split(":");
              if (!doc_id || doc_id !== sheet?.documentId) return;
              sheet?.change(d => {
                for (const { path, action, value } of patches)
                  switch (path.length) {
                    case 0: {
                      d.data[action](...value);
                      break;
                    }
                    case 1: {
                      const [y] = path;
                      if (action === "set") d.data[y] = value;
                      else d.data[y][action](...value);
                      break;
                    }
                    case 2: {
                      const [y, x] = path;
                      if (!d.data[y]) d.data[y] = {};
                      if (action === "set") d.data[y][x] = value;
                      else d.data[y][x][action](...value);
                      break;
                    }
                    default:
                      throw new Error("TODO: path");
                  }
              });
            }),
          );
        }
      } catch (error) {
        console.error(error);
        app.ports.docErrored.send(error?.message ?? "Something went wrong.");
      }
    </script>
  </body>
</html>
