<!doctype html>
<html lang="en">
  <head>
    <title>scrapsheets</title>
    <meta charset="UTF-8" />
    <meta name="author" content="Taylor Troesh" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="dark light" />
    <meta
      name="theme-color"
      content="#ffffff"
      media="(prefers-color-scheme: light)" />
    <meta
      name="theme-color"
      content="#151515"
      media="(prefers-color-scheme: dark)" />
    <link href="/style.css" rel="stylesheet" />
    <script src="/index.js"></script>
  </head>
  <body>
    <div id="elm"></div>
    <script type="module">
      import * as AM from "https://esm.sh/@automerge/react@2.0.0/slim?bundle-deps";
      await AM.initializeWasm(
        fetch("https://esm.sh/@automerge/automerge/dist/automerge.wasm"),
      );

      try {
        const app = Elm.Main.init({
          node: document.getElementById("elm"),
          flags: {},
        });

        const Library = {
          get: () => {
            return {
              ...JSON.parse(
                localStorage.getItem("scrapsheets-library") ?? "{}",
              ),
              "": { name: "library", doc: { type: "library" } },
              "portal:shop": { name: "shop" },
              "template:table": {
                name: "table",
                doc: {
                  type: "template",
                  data: [
                    "table",
                    [
                      ["a", "int", 0],
                      ["b", "int", 1],
                      ["c", "int", 2],
                    ],
                  ],
                },
              },
            };
          },
          set: (id, info) => {
            for (const i in info) if (info[i] === null) delete info[i];
            const library = JSON.parse(
              localStorage.getItem("scrapsheets-library") ?? "{}",
            );
            localStorage.setItem(
              "scrapsheets-library",
              JSON.stringify({ ...library, [id]: { ...library[id], ...info } }),
            );
            app.ports.librarySynced.send(Library.get());
          },
        };
        app.ports.librarySynced.send(Library.get());

        app?.ports?.updateLibrary?.subscribe(({ id, data }) =>
          Library.set(id, data),
        );

        const repo = new AM.Repo({
          storage: new AM.IndexedDBStorageAdapter(),
          // network: [new AM.BrowserWebSocketClientAdapter("wss://sync.automerge.org")],
        });

        {
          let sheet;

          app?.ports?.changeId?.subscribe(async id => {
            const [type, doc_id = ""] = id.split(":");
            if (doc_id === sheet?.documentId) return;
            // TODO: Remove existing listeners.
            sheet = await repo.find(doc_id).catch(() => null);
            const doc = Library.get()[id]?.doc ?? (await sheet?.doc?.());
            app.ports.docSelected.send({
              id,
              data: { doc: doc && { ...doc } },
            });
            sheet?.on?.("change", data => {
              app.ports.docChanged.send({
                id: type + ":" + data.handle.documentId,
                data,
              });
            });
          });

          app?.ports?.newDoc?.subscribe(async ({ type_: type, data }) => {
            sheet = repo.create({ type, data: [data] });
            const id = `${type}:${sheet.documentId}`;
            Library.set(id, { name: "", tags: [] });
            const doc = Library.get()[id]?.doc ?? (await sheet?.doc?.());
            app.ports.docSelected.send({
              id,
              data: { doc: doc && { ...doc } },
            });
          });

          app?.ports?.changeDoc?.subscribe(
            // TODO: Use custom patches for now.
            ({ id, data: patches }) => {
              const [type, doc_id] = id.split(":");
              if (!doc_id || doc_id !== sheet?.documentId) return;
              for (const patch of patches) {
                sheet?.change(d => {
                  if (!d.cols) d.cols = [];
                  if (!d.rows) d.rows = [];
                  switch (patch.action) {
                    case "cell-put":
                      const [_, y, x] = patch.path;
                      if (!d.rows[y]) d.rows[y] = {};
                      d.rows[y][x] = patch.value;
                      break;
                    case "row-insert":
                      d.rows.insertAt(1 + patch.path[1], patch.value);
                      break;
                    case "col-insert":
                      // TODO: Intelligently pick a column based on existing columns and rows.
                      d.cols.push({
                        key: Math.random().toString().slice(2),
                        label: Math.random().toString().slice(2),
                        type: "same",
                      });
                      break;
                    case "row-del":
                      d.rows.deleteAt(patch.path[1]);
                      break;
                    case "col-del":
                      d.cols.deleteAt(patch.path[1]);
                      break;
                    default:
                      throw new Error("TODO");
                  }
                });
              }
            },
          );
        }
      } catch (error) {
        console.error(error);
      }
    </script>
  </body>
</html>
