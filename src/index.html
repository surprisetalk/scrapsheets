<!doctype html>
<html lang="en">
  <head>
    <title>scrapsheets</title>
    <meta charset="UTF-8" />
    <meta name="author" content="Taylor Troesh" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="dark light" />
    <meta
      name="theme-color"
      content="#ffffff"
      media="(prefers-color-scheme: light)" />
    <meta
      name="theme-color"
      content="#151515"
      media="(prefers-color-scheme: dark)" />
    <link href="/style.css" rel="stylesheet" />
    <script src="/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/alasql@4"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap");
    </style>
  </head>
  <body>
    <div id="elm"></div>
    <script type="module">
      import * as AM from "/automerge.js";

      function debounce(func, timeout = 300) {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => {
            func.apply(this, args);
          }, timeout);
        };
      }

      try {
        const app = Elm.Main.init({
          node: document.getElementById("elm"),
          flags: {},
        });

        function catchy(func) {
          return (...args) => {
            try {
              return func.apply(this, args)?.catch(error => {
                console.error(error);
                app.ports.docErrored.send(
                  error?.message ?? "Something went wrong.",
                );
              });
            } catch (error) {
              console.error(error);
              app.ports.docErrored.send(
                error?.message ?? "Something went wrong.",
              );
            }
          };
        }

        const Col = (val, key) => {
          const [name, type] = val.split("::");
          return {
            name: name,
            type: type ?? "text",
            key: key.toString(),
          };
        };

        const Table = (cols, ...rows) => ({
          type: "table",
          data: [cols, ...rows],
        });

        const QuerySql = (cols, code, ...examples) => ({
          type: "query",
          data: [
            {
              lang: "sql",
              code,
              cols,
              args: {},
              examples,
            },
          ],
        });

        const Library = {
          get: () => {
            const examples = {
              // "table:calculated-columns": Table(
              //   [
              //     { key: 0, name: "a", type: "int" },
              //     { key: 1, name: "b", type: "int" },
              //     {
              //       key: 2,
              //       name: "c",
              //       type: { lang: "formula", code: "a + b" },
              //     },
              //   ],
              //   ...[
              //     [1, 2],
              //     [2, 4],
              //     [3, 6],
              //   ],
              // ),
              // "table:postman": Table(
              //   [
              //     { key: 0, name: "method", type: "text" },
              //     { key: 1, name: "url", type: "text" },
              //     { key: 2, name: "fields", type: "list field" },
              //     {
              //       key: 3,
              //       name: "form",
              //       type: {
              //         lang: "scrapscript",
              //         code: "form {method,url,fields}",
              //       },
              //     },
              //   ],
              //   ...[
              //     [
              //       "GET",
              //       "example.com/foo",
              //       [
              //         { label: "hello", type: "text" },
              //         { label: "world", type: "date" },
              //       ],
              //     ],
              //     [
              //       "POST",
              //       "example.com/bar",
              //       [
              //         {
              //           label: "my dropdown",
              //           key: "my_dropdown",
              //           type: { 1: "label a", 2: "label b" },
              //           default: 2,
              //         },
              //       ],
              //     ],
              //   ],
              // ),
              // "table:nested": Table(
              //   [
              //     { key: 0, name: "a", type: "list text" },
              //     { key: 1, name: "b", type: "dict text text" },
              //     { key: 1, name: "c", type: "dict text (list text)" },
              //   ],
              //   ...[
              //     [
              //       ["a", "b"],
              //       { c: "d", e: "f" },
              //       { g: ["h", "i"], j: ["k", "l", "m"] },
              //     ],
              //     [["n"], { o: "p" }, { q: [], r: ["s", "t"] }],
              //   ],
              // ),
              "query:http-get": QuerySql(
                {},
                "select http('https://taylor.town/random')->res as random_number",
              ),
              // "query:python": QuerySql({},
              //   "return [[{'name':'a','type':'text','key':'a'}], {'a':1}, {'a':2}, {'a':3}]",
              // ),
              // "query:stonks": QuerySql({},
              //   "select stonks->>'id', stonks->>'price' from http('https://taylor.town/stonks'), json(res) stonks",
              // ),
              // TODO: Move these to the shop.
              ...{
                "query:bluesky-actors": QuerySql(
                  {
                    avatar: "image",
                    did: "link",
                    handle: "text",
                    displayName: "text",
                  },
                  "" +
                    "search actors/ return (" +
                    "\n  avatar," +
                    "\n  'http://bsky.app/profile/'||(@a->did) as did," +
                    "\n  handle," +
                    "\n  displayName" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://public.api.bsky.app/xrpc/app.bsky.actor.searchActors'," +
                    "\n  @{q:(coalesce(@params->(''),'example'))}" +
                    "\n)",
                  "taylor.town",
                  "memes",
                ),
                "query:github-repos": QuerySql(
                  {
                    repo: "link",
                    full_name: "text",
                    description: "text",
                    lang: "text",
                    license: "text",
                    stargazers: "int",
                    open_issues: "int",
                  },
                  "" +
                    "search items/ return (" +
                    "\n  'http://github.com/'||(@x->full_name) as repo," +
                    "\n  full_name," +
                    "\n  description," +
                    "\n  language as lang," +
                    "\n  license->key as license," +
                    "\n  stargazers_count as stargazers," +
                    "\n  open_issues_count as open_issues" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://api.github.com/search/repositories'," +
                    "\n  @{q:(coalesce(@params->(''),'example'))}" +
                    "\n)",
                  "scrapscript sort=stars",
                  "surprisetalk sort=updated",
                  "jquery in:name,description",
                  "jquery in:readme ",
                  "repo:octocat/hello-world",
                  "user:surprisetalk forks:>100 ",
                  "org:scrapscript",
                  "size:>=30000",
                  "size:<50",
                  "size:50..120",
                  "node followers:>=10000",
                  "stars:>=500 language:php",
                  "css pushed:>2013-02-01",
                  "webos created:<2011-01-01",
                  "rails language:javascript",
                  "license:apache-2.0",
                  "archived:true GNOME",
                  "help-wanted-issues:>n",
                  "good-first-issues:>n",
                  "is:sponsorable",
                ),
                "query:github-users": QuerySql(
                  {
                    avatar: "image",
                    url: "link",
                    handle: "text",
                    type: "text",
                  },
                  "" +
                    "search items/ as @x return (" +
                    "\n  avatar_url as avatar," +
                    "\n  url," +
                    "\n  login as handle," +
                    "\n  type" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://api.github.com/search/users'," +
                    "\n  @{q:(coalesce(@params->(''),'example'))}" +
                    "\n)",
                  "surprisetalk sort=followers",
                  "foo sort=joined",
                  "mike in:name created:<2011-01-01 type:user",
                  "data in:email type:org",
                  "user:octocat",
                  "org:electron type:user",
                  "kenya in:login",
                  "bolton in:name",
                  "fullname:nat friedman",
                  "data in:email",
                  "repos:>9000",
                  "repos:1 location:iceland",
                  "language:javascript location:russia",
                  "jenny language:javascript in:fullname",
                  "created:2010-01-01..2011-01-01 john in:login",
                  "followers:>=1000",
                  "is:sponsorable",
                ),
                // "query:github-commits": QuerySql({},
                //   "select * from @(http('https://api.github.com/search/commits', @{q:(@params->(''))})->res->items)",
                //   "repo:tekknolagi/scrapscript",
                //   "surprisetalk",
                // ),
                "query:github-prs-issues": QuerySql(
                  {
                    id: "text",
                    number: "number",
                    title: "text",
                    url: "link",
                    avatar: "image",
                    login: "text",
                    labels: "text",
                    state: "text",
                    locked: "bool",
                    assignee_avatar: "image",
                    assignee_login: "text",
                    milestone: "text",
                    comments: "text",
                    created_at: "datetime",
                    updated_at: "datetime",
                    closed_at: "datetime",
                    author_association: "text",
                    type: "text",
                    draft: "text",
                    html_url: "link",
                    body: "text",
                    reactions: "text",
                  },
                  "" +
                    "search items/ as @x labels/ as @label return (" +
                    "\n  @x->id as id," +
                    "\n  @x->number as number," +
                    "\n  @x->title as title," +
                    "\n  @x->html_url as url," +
                    "\n  @x->user->avatar_url as avatar," +
                    "\n  @x->user->login as login," +
                    "\n  @label->name as labels," +
                    "\n  @x->state as state," +
                    "\n  @x->locked as locked," +
                    "\n  @x->assignee->avatar_url as assignee_avatar," +
                    "\n  @x->assignee->login as assignee_login," +
                    "\n  @x->milestone as milestone," +
                    "\n  @x->comments as comments," +
                    "\n  @x->created_at as created_at," +
                    "\n  @x->updated_at as updated_at," +
                    "\n  @x->closed_at as closed_at," +
                    "\n  @x->author_association as author_association," +
                    "\n  @x->type as type," +
                    "\n  @x->draft as draft," +
                    "\n  @x->pull_request->html_url as html_url," +
                    "\n  @x->body as body," +
                    "\n  @x->reactions->total_count as reactions" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://api.github.com/search/issues'," +
                    "\n  @{q:(coalesce(@params->(''),'example'))}" +
                    "\n)",
                  "repo:tekknolagi/scrapscript",
                  "user:surprisetalk",
                  "author:surprisetalk",
                  "assignee:surprisetalk",
                  "commenter:surprisetalk",
                  "language:ruby",
                  "state:closed comments:>100",
                  "draft:true",
                  "interactions:>2000",
                  "reactions:>1000",
                  "archived:false gnome",
                  "gnome is:unmerged",
                  "language:javascript merged:<2011-01-01",
                  "language:c# created:<2011-01-01 state:open",
                  "type:pr review-requested:benbalter",
                  "type:pr reviewed-by:gjtorikian",
                  "type:pr review:changes_requested",
                  "mentions:surprisetalk",
                  "team:example/example",
                  "bug type:issue sort=reactions-+1",
                  "type:pr sort=comments",
                  "oops in:title,body,comments",
                  "state:open",
                  "sort=reactions-smile",
                  "sort=updated",
                ),
                "query:crypto-markets": QuerySql(
                  {
                    image: "image",
                    rank: "int",
                    name: "text",
                    symbol: "text",
                    price: "usd",
                    market_cap: "usd",
                    high_24h: "usd",
                    low_24h: "usd",
                    change_24h: "usd",
                    ath: "usd",
                    ath_date: "datetime",
                  },
                  "" +
                    "search / return (" +
                    "\n  image," +
                    "\n  market_cap_rank as rank," +
                    "\n  name," +
                    "\n  symbol," +
                    "\n  current_price as price," +
                    "\n  market_cap," +
                    "\n  high_24h," +
                    "\n  low_24h," +
                    "\n  price_change_percentage_24h as change_24h," +
                    "\n  ath," +
                    "\n  ath_date" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://api.coingecko.com/api/v3/coins/markets'," +
                    "\n  @{vs_currency:'usd', `order`:'market_cap_desc', per_page:100}" +
                    "\n)",
                ),
                "query:crypto-search": QuerySql(
                  {
                    thumb: "image",
                    rank: "int",
                    name: "text",
                    symbol: "text",
                  },
                  "" +
                    "search coins/ return (" +
                    "\n  market_cap_rank as rank," +
                    "\n  thumb," +
                    "\n  symbol," +
                    "\n  name" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://api.coingecko.com/api/v3/search'," +
                    "\n  @{`query`:(coalesce(@params->(''),'bitcoin'))}" +
                    "\n)",
                  "bitcoin",
                  "ethereum",
                  "doge",
                ),
                "query:hackernews-search": QuerySql(
                  {
                    id: "text",
                    url: "link",
                    title: "text",
                    author: "text",
                    points: "num",
                    comments: "num",
                    created_at: "datetime",
                    updated_at: "datetime",
                  },
                  "" +
                    "search hits/ return (" +
                    "\n  story_id as id," +
                    "\n  url," +
                    "\n  title," +
                    "\n  author," +
                    "\n  points," +
                    "\n  num_comments as comments," +
                    "\n  created_at," +
                    "\n  updated_at" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://hn.algolia.com/api/v1/search'," +
                    "\n  @{`query`:(coalesce(@params->(''),'example'))}" +
                    "\n)",
                  "taylor.town",
                ),
                "query:hackernews-top": QuerySql(
                  {
                    title: "text",
                    author: "text",
                    hn_url: "link",
                    url: "link",
                    published_at: "datetime",
                  },
                  "" +
                    "search items/ return (" +
                    "\n  title," +
                    "\n  author->name as author," +
                    "\n  external_url as hn_url," +
                    "\n  url," +
                    "\n  date_published as published_at" +
                    "\n)" +
                    "\nfrom http('https://corsproxy.io/?url=https://hnrss.org/frontpage.jsonfeed')",
                ),
                "query:arxiv-search": QuerySql(
                  {
                    id: "link",
                    title: "text",
                    summary: "text",
                    published: "datetime",
                    updated: "datetime",
                    authors: "text",
                    cat: "text",
                  },
                  "" +
                    "search entries / return (" +
                    "\n  id," +
                    "\n  categories as cat," +
                    "\n  title," +
                    "\n  summary," +
                    "\n  authors," +
                    "\n  published," +
                    "\n  updated" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://export.arxiv.org/api/query'," +
                    "\n  @{search_query:('all:' || (@params->(''))), max_results:25}" +
                    "\n)",
                ),
                "query:wikipedia-search": QuerySql(
                  { i: "number", thumb: "image", title: "text", url: "link" },
                  "" +
                    "search `query` pages / return (" +
                    // "\n  `index` as i," +
                    "\n  thumbnail->source as thumb," +
                    "\n  title," +
                    "\n  fullurl as url" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://en.wikipedia.org/w/api.php'," +
                    "\n  @{" +
                    "\n     action:'query'," +
                    "\n     generator:'search'," +
                    "\n     prop:'pageimages|info'," +
                    "\n     piprop:'thumbnail'," +
                    "\n     pithumbsize:100," +
                    "\n     inprop:'url'," +
                    "\n     exintro:''," +
                    "\n     explaintext:''," +
                    "\n     `gsrsearch`:(@params->(''))," +
                    "\n     gsrlimit:25," +
                    "\n     format:'json'," +
                    "\n     origin:'*'" +
                    "\n   }" +
                    "\n)",
                ),
                "query:reddit-search": QuerySql(
                  {
                    preview: "image",
                    ups: "int",
                    downs: "int",
                    comms: "int",
                    created: "datetime",
                    thumbnail: "image",
                    subreddit: "text",
                    subs: "int",
                    title: "text",
                    selftext: "text",
                    author: "text",
                    is_self: "bool",
                    spoiler: "bool",
                    type: "text",
                    domain: "text",
                    reddit_url: "link",
                    url: "link",
                    dest_url: "link",
                  },
                  "" +
                    "search data children / data return (" +
                    // "\n  preview->images->(0)->resolutions->(0)->url as preview," +
                    "\n  thumbnail," +
                    "\n  title," +
                    // "\n  selftext," +
                    "\n  'https://old.reddit.com'||permalink as reddit_url," +
                    "\n  url," +
                    "\n  url_overridden_by_dest as dest_url," +
                    "\n  domain," +
                    "\n  post_hint as type," +
                    "\n  ups," +
                    "\n  downs," +
                    "\n  is_self," +
                    "\n  spoiler," +
                    "\n  num_comments as comms," +
                    "\n  author," +
                    "\n  subreddit," +
                    "\n  subreddit_subscribers as subs," +
                    "\n  created" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://www.reddit.com/search.json'," +
                    "\n  @{q:(@params->('')), limit:25}" +
                    "\n)",
                ),
                "query:reddit-subreddit": QuerySql(
                  {
                    preview: "image",
                    ups: "int",
                    downs: "int",
                    comms: "int",
                    created: "datetime",
                    thumbnail: "image",
                    subreddit: "text",
                    subs: "int",
                    title: "text",
                    selftext: "text",
                    author: "text",
                    is_self: "bool",
                    spoiler: "bool",
                    type: "text",
                    domain: "text",
                    reddit_url: "link",
                    url: "link",
                    dest_url: "link",
                  },
                  "" +
                    "search data children / data return (" +
                    // "\n  preview->images->(0)->resolutions->(0)->url as preview," +
                    "\n  thumbnail," +
                    "\n  title," +
                    // "\n  selftext," +
                    "\n  'https://old.reddit.com'||permalink as reddit_url," +
                    "\n  url," +
                    "\n  url_overridden_by_dest as dest_url," +
                    "\n  domain," +
                    "\n  post_hint as type," +
                    "\n  ups," +
                    "\n  downs," +
                    "\n  is_self," +
                    "\n  spoiler," +
                    "\n  num_comments as comms," +
                    "\n  author," +
                    "\n  subreddit," +
                    "\n  subreddit_subscribers as subs," +
                    "\n  created" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://www.reddit.com/r/'||(coalesce(@params->(''),'all'))||'.json'," +
                    "\n  @{limit:25}" +
                    "\n)",
                  "hmmm",
                ),
                "query:manifold-search": QuerySql(
                  {
                    creatorAvatarUrl: "image",
                    url: "link",
                    question: "text",
                    creatorUsername: "text",
                    createdTime: "datetime",
                    closeTime: "datetime",
                    resolutionTime: "datetime",
                    resolution: "text",
                    totalLiquidity: "float",
                    volume: "float",
                    volume24Hours: "float",
                    uniqes: "int",
                    pool: "text",
                  },
                  "" +
                    "search / return (" +
                    "\n  url," +
                    "\n  question," +
                    // "\n  id," +
                    // "\n  creatorAvatarUrl," +
                    // "\n  creatorId," +
                    "\n  creatorUsername," +
                    // "\n  creatorName," +
                    "\n  createdTime," +
                    "\n  closeTime," +
                    "\n  resolutionTime," +
                    "\n  resolution," +
                    // "\n  outcome," +
                    // "\n  mechanism," +
                    "\n  volume24Hours," +
                    "\n  volume," +
                    "\n  totalLiquidity," +
                    // "\n  isResolved," +
                    "\n  uniqueBettorCount as uniqes," +
                    // "\n  lastUpdatedTime," +
                    // "\n  lastBetTime," +
                    // "\n  lastCommentTime," +
                    // "\n  token," +
                    "\n  pool" +
                    // "\n  probability," +
                    // "\n  p," +
                    // "\n  resolutionProbability," +
                    // "\n  `value`," +
                    // "\n  `min`," +
                    // "\n  `max`," +
                    // "\n  isLogScale" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://api.manifold.markets/v0/search-markets'," +
                    "\n  @{term:(@params->('')), limit:25}" +
                    "\n)",
                ),
                "query:manifold-trending": QuerySql(
                  {
                    creatorAvatarUrl: "image",
                    url: "link",
                    question: "text",
                    creatorUsername: "text",
                    createdTime: "datetime",
                    closeTime: "datetime",
                    resolutionTime: "datetime",
                    resolution: "text",
                    outcomeType: "text",
                    totalLiquidity: "float",
                    volume: "float",
                    volume24Hours: "float",
                    uniqes: "int",
                    pool: "text",
                  },
                  "" +
                    "search / return (" +
                    "\n  url," +
                    "\n  question," +
                    // "\n  id," +
                    // "\n  creatorAvatarUrl," +
                    // "\n  creatorId," +
                    "\n  creatorUsername," +
                    // "\n  creatorName," +
                    "\n  createdTime," +
                    "\n  closeTime," +
                    "\n  resolutionTime," +
                    "\n  resolution," +
                    // "\n  mechanism," +
                    "\n  volume24Hours," +
                    "\n  volume," +
                    "\n  totalLiquidity," +
                    // "\n  isResolved," +
                    "\n  uniqueBettorCount as uniqes," +
                    // "\n  lastUpdatedTime," +
                    // "\n  lastBetTime," +
                    // "\n  lastCommentTime," +
                    // "\n  token," +
                    "\n  pool," +
                    // "\n  probability," +
                    // "\n  p," +
                    // "\n  resolutionProbability," +
                    // "\n  `value`," +
                    // "\n  `min`," +
                    // "\n  `max`," +
                    // "\n  isLogScale" +
                    "\n  outcomeType" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://api.manifold.markets/v0/markets'," +
                    "\n  @{limit:25}" +
                    "\n)",
                ),
                // "query:fred-search": QuerySql({},
                //   "select * from @(http('https://corsproxy.io/?url=https://api.stlouisfed.org/fred/series/search', @{search_text:(@params->('')), file_type:'json'})->res)"
                // ),
                "query:stocks-search": QuerySql(
                  {
                    link: "link",
                    thumb: "image",
                    title: "text",
                    publisher: "text",
                    publishedAt: "datetime",
                    tickers: "text",
                  },
                  "" +
                    "search news / return (" +
                    "\n  link," +
                    "\n  thumbnail->resolutions->(1)->url as thumb," +
                    "\n  title," +
                    "\n  publisher," +
                    "\n  providerPublishTime as publishedAt," +
                    "\n  relatedTickers as tickers" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://corsproxy.io/?url=https://query1.finance.yahoo.com/v1/finance/search'," +
                    "\n  @{q:(@params->(''))}" +
                    "\n)",
                  "AAPL",
                ),
                // "query:discogs-search": QuerySql({},
                //   "select * from @(http('https://api.discogs.com/database/search', @{q:(@params->('')), type:'release'})->res)"
                // ),
                "query:speedrun-games": QuerySql(
                  {
                    thumb: "image",
                    url: "link",
                    title: "text",
                    release: "date",
                    discord: "link",
                  },
                  "" +
                    "search data / return (" +
                    "\n  weblink as url," +
                    "\n  assets->`cover-tiny`->uri as thumb," +
                    "\n  names->international as title," +
                    "\n  `release-date` as release," +
                    "\n  discord" +
                    "\n)" +
                    "\nfrom http('https://www.speedrun.com/api/v1/games', @{name:(@params->(''))})",
                  "mario",
                  "zelda",
                ),
                "query:speedrun-users": QuerySql(
                  {
                    url: "link",
                    thumb: "image",
                    location: "text",
                    signup: "datetime",
                    twitch: "link",
                    hitbox: "link",
                    youtube: "link",
                    twitter: "link",
                    live: "link",
                  },
                  "" +
                    "search data / return (" +
                    "\n  weblink as url," +
                    "\n  assets->image->uri as thumb," +
                    "\n  names->international as name," +
                    "\n  location->region->code as location," +
                    "\n  twitch->uri as twitch," +
                    "\n  hitbox->uri as hitbox," +
                    "\n  youtube->uri as youtube," +
                    "\n  twitter->uri as twitter," +
                    "\n  speedrunslive->uri as live," +
                    "\n  signup" +
                    "\n)" +
                    "\nfrom http('https://www.speedrun.com/api/v1/users', @{name:(@params->(''))})",
                  "mario",
                  "zelda",
                ),
                // "query:youtube-search": QuerySql({},
                //   "select * from @(http('https://www.googleapis.com/youtube/v3/search', @{part:'snippet', q:(@params->('')), key:'YOUR_API_KEY', maxResults:25})->res->items)",
                //   "videogamedunkey"
                // ),
                "query:podcast-search": QuerySql(
                  {
                    artistName: "text",
                    collectionName: "text",
                    trackName: "text",
                    colUrl: "link",
                    trackUrl: "link",
                    feedUrl: "link",
                    artworkUrl100: "image",
                    releaseDate: "datetime",
                    trackCount: "int",
                    country: "text",
                    genre: "text",
                    genres: "text",
                    trackTimeMillis: "int",
                    artistUrl: "link",
                  },
                  "" +
                    "search results / return (" +
                    "\n feedUrl," +
                    "\n trackViewUrl as trackUrl," +
                    "\n artworkUrl100," +
                    "\n artistName," +
                    // "\n collectionName," +
                    "\n trackName," +
                    // "\n collectionViewUrl as colUrl," +
                    // "\n trackCount," +
                    // "\n country," +
                    "\n primaryGenreName as genre," +
                    // "\n genres," +
                    // "\n trackTimeMillis," +
                    // "\n artistViewUrl as artistUrl," +
                    "\n releaseDate" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://itunes.apple.com/search'," +
                    "\n  @{term:(@params->('')), media:'podcast', limit:25}" +
                    "\n)",
                  "articles of interest",
                ),
                "query:ossinsight-trends": QuerySql(
                  {
                    repo: "text",
                    lang: "text",
                    desc: "text",
                    stars: "int",
                    forks: "int",
                    prs: "int",
                    pushes: "int",
                    total_score: "float",
                    contributors: "text",
                    cats: "text",
                  },
                  "" +
                    "search data `rows` / return (" +
                    "\n  repo_name as repo," +
                    "\n  description as `desc`," +
                    "\n  primary_language as lang," +
                    "\n  contributor_logins as contributors," +
                    // "\n  collections_names as cats," +
                    "\n  stars," +
                    "\n  forks," +
                    "\n  pull_requests as prs," +
                    "\n  pushes," +
                    "\n  total_score" +
                    "\n)" +
                    "\nfrom http(" +
                    "\n  'https://api.ossinsight.io/v1/trends/repos'," +
                    "\n  @{keyword:(@params->(''))}" +
                    "\n)",
                  "language=All period=past_24_hours",
                  "language=JavaScript period=past_3_months",
                  "language=Erlang",
                ),
              },
            };
            return {
              ...Object.fromEntries(
                Object.entries(examples).map(([k, v]) => [
                  k,
                  { name: k.split(":").pop(), scratch: true, doc: v },
                ]),
              ),
              ...JSON.parse(
                localStorage.getItem("scrapsheets-library") ?? "{}",
              ),
              "": { name: "library", doc: { type: "library" } },
              // "portal:shop": { name: "shop" },
              "table:tutorial": {
                name: "tutorial",
                scratch: true,
                doc: Table(
                  ["text::text", "examples::text"].map(Col),
                  ["chapter 1", []],
                  ["chapter 2", []],
                  ["chapter 3", []],
                ),
              },
              "table:examples": {
                name: "examples",
                scratch: true,
                doc: Table(
                  ["sheet_id::sheet_id", "name::text"].map(Col),
                  ...Object.entries(examples).map(([k, v]) => [
                    k,
                    k.split(":").pop(),
                  ]),
                ),
              },
            };
          },
          set: (id, info) => {
            for (const i in info) if (info[i] === null) delete info[i];
            const library = JSON.parse(
              localStorage.getItem("scrapsheets-library") ?? "{}",
            );
            localStorage.setItem(
              "scrapsheets-library",
              JSON.stringify({ ...library, [id]: { ...library[id], ...info } }),
            );
            app.ports.librarySynced.send(Library.get());
          },
          delete: id => {
            const library = JSON.parse(
              localStorage.getItem("scrapsheets-library") ?? "{}",
            );
            localStorage.setItem(
              "scrapsheets-library",
              JSON.stringify({ ...library, [id]: undefined }),
            );
            app.ports.librarySynced.send(Library.get());
          },
        };
        app.ports.librarySynced.send(Library.get());

        app.ports.deleteDoc.subscribe(async id => Library.delete(id));

        app.ports.updateLibrary.subscribe(({ id, data }) =>
          Library.set(id, data),
        );

        {
          await AM.initializeWasm(fetch("/automerge.wasm"));

          const repo = new AM.Repo({
            storage: new AM.IndexedDBStorageAdapter(),
            // network: [new AM.BrowserWebSocketClientAdapter("wss://sync.automerge.org")],
          });

          let sheet;

          alasql.options.modifier = "RECORDSET";
          for (const type of [
            "image",
            "link",
            "usd",
            "percentage",
            "date",
            "int",
            "float",
          ])
            alasql.fn[type] = data => ({ type, data });
          alasql.from.SHEET = (id, params = {}) => {
            // TODO: Grab sheet (e.g. portal) with given params.
            throw new Error("TODO");
          };
          alasql.fn.http = (url, qs = {}) => {
            const atomToJson = xmlString => {
              const parser = new DOMParser();
              const doc = parser.parseFromString(xmlString, "text/xml");
              const feed = {
                title: doc.querySelector("feed > title")?.textContent,
                updated: doc.querySelector("feed > updated")?.textContent,
                totalResults: parseInt(
                  doc.querySelector("totalResults")?.textContent || "0",
                ),
                entries: [],
              };
              doc.querySelectorAll("entry").forEach(entry => {
                feed.entries.push({
                  id: entry.querySelector("id")?.textContent,
                  title: entry.querySelector("title")?.textContent?.trim(),
                  summary: entry.querySelector("summary")?.textContent?.trim(),
                  published: entry.querySelector("published")?.textContent,
                  updated: entry.querySelector("updated")?.textContent,
                  authors: Array.from(
                    entry.querySelectorAll("author name"),
                  ).map(a => a.textContent),
                  links: Array.from(entry.querySelectorAll("link")).map(l => ({
                    href: l.getAttribute("href"),
                    rel: l.getAttribute("rel"),
                    type: l.getAttribute("type"),
                  })),
                  categories: Array.from(
                    entry.querySelectorAll("category"),
                  ).map(c => c.getAttribute("term")),
                });
              });
              return feed;
            };
            const parsers = {
              "application/atom+xml": atomToJson,
            };
            if (!url) return;
            const request = new XMLHttpRequest();
            request.open("GET", url + "?" + new URLSearchParams(qs), false); // `false` makes the request synchronous
            request.send(null);
            return {
              status: request.status,
              res:
                (
                  parsers?.[
                    request
                      .getResponseHeader("Content-Type")
                      ?.replace(/;.*$/, "") || "application/json"
                  ] ?? JSON.parse
                )?.(request.responseText) || null,
            };
          };
          alasql.from.HTTP = (url, qs = {}) => {
            const { status, res } = alasql.fn.http(url, qs);
            if (status >= 400) throw new Error("Something went wrong.");
            return res;
          };
          const queryDoc = debounce(
            catchy(async (id, { code, lang, args, cols: cols_ = {} }) => {
              switch (lang) {
                case "sql":
                  // TODO: Run alasql if possible, otherwise post to /query.
                  const params = new URLSearchParams(window.location.search)
                    .get("q")
                    ?.split(/\s+(?=\w+=)/)
                    .reduce(
                      (r, p) => {
                        const [k, v] = p.includes("=") ? p.split("=") : ["", p];
                        return ((r[k] ||= []).push(v), r);
                      },
                      { "": [].join(" ") },
                    ) ?? { "": null };
                  const [, { columns: cols, data: rows } = {}] = await alasql([
                    [`set @params = ?`, [params]],
                    code,
                  ]);
                  // TODO: If doc contains cols data, use that names and types.
                  app.ports.docQueried.send({
                    id,
                    data: [
                      cols.map(col => ({
                        key: col.columnid,
                        name: col.columnid,
                        type: cols_?.[col.columnid] ?? null,
                      })),
                      ...rows,
                    ],
                  });
                  break;
                default:
                  throw new Error(`TODO: ${lang}`);
              }
            }),
            300,
          );
          app.ports.queryDoc.subscribe(({ id, data }) => queryDoc(id, data));

          const selectDoc = catchy(async (id, sheet) => {
            const [type, doc_id] = id.split(":");
            const doc = Library.get()[id]?.doc ?? sheet?.doc?.();
            app.ports.docSelected.send({
              id,
              data: { doc: doc && { ...doc } },
            });
            if (type === "query") queryDoc(id, doc.data[0]);
            sheet?.on?.("change", data => {
              app.ports.docChanged.send({
                id: type + ":" + data.handle.documentId,
                data,
              });
              if (type === "query") queryDoc(id, data.doc.data[0]);
            });
          });

          const changeId = catchy(async id => {
            const [, doc_id = ""] = id.split(":");
            if (doc_id === sheet?.documentId) return;
            // TODO: Remove existing listeners.
            sheet = await repo?.find(doc_id).catch(() => null);
            await selectDoc(id, sheet);
          });
          app.ports.changeId.subscribe(changeId);
          changeId(window.location.pathname.slice(1));

          app.ports.newDoc.subscribe(
            catchy(async ({ type, data }) => {
              // TODO: Remove existing listeners.
              sheet = repo?.create({ type, data });
              const id = `${type}:${sheet.documentId}`;
              Library.set(id, { name: "", tags: [] });
              await selectDoc(id, sheet);
            }),
          );

          app.ports.changeDoc.subscribe(
            catchy(async ({ id, data: patches }) => {
              const [type, doc_id] = id.split(":");
              {
                const doc = Library.get()[id]?.doc;
                if (doc) {
                  const d = { ...doc };
                  for (const { path, action, value } of patches)
                    switch (path.length) {
                      case 2: {
                        const [y, x] = path;
                        if (!d.data[y]) d.data[y] = {};
                        if (action === "set") d.data[y][x] = value;
                        else d.data[y][x][action](...value);
                        break;
                      }
                      default:
                        throw new Error("TODO: path");
                    }
                  app.ports.docChanged.send({
                    id,
                    data: {
                      doc: d,
                      handle: null,
                      patchInfo: null,
                      patches: [],
                    },
                  });
                  if (type === "query") queryDoc(id, d.data[0]);
                  return;
                }
              }
              sheet?.change(d => {
                for (const { path, action, value } of patches)
                  switch (path.length) {
                    case 0: {
                      d.data[action](...value);
                      break;
                    }
                    case 1: {
                      const [y] = path;
                      if (action === "set") d.data[y] = value;
                      else d.data[y][action](...value);
                      break;
                    }
                    case 2: {
                      const [y, x] = path;
                      if (!d.data[y]) d.data[y] = {};
                      if (action === "set") d.data[y][x] = value;
                      else d.data[y][x][action](...value);
                      break;
                    }
                    default:
                      throw new Error("TODO: path");
                  }
              });
            }),
          );
        }
      } catch (error) {
        console.error(error);
        app.ports.docErrored.send(error?.message ?? "Something went wrong.");
      }
    </script>
  </body>
</html>
