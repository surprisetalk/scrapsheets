<!doctype html>
<html lang="en">
  <head>
    <title>scrapsheets</title>
    <meta charset="UTF-8" />
    <meta name="author" content="Taylor Troesh" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="dark light" />
    <meta
      name="theme-color"
      content="#ffffff"
      media="(prefers-color-scheme: light)" />
    <meta
      name="theme-color"
      content="#151515"
      media="(prefers-color-scheme: dark)" />
    <link href="/style.css" rel="stylesheet" />
    <script src="/index.js"></script>
  </head>
  <body>
    <div id="elm"></div>
    <script type="module">
      import * as AM from "https://esm.sh/@automerge/react@2.0.0/slim?bundle-deps";
      await AM.initializeWasm(
        fetch("https://esm.sh/@automerge/automerge/dist/automerge.wasm"),
      );

      try {
        const repo = new AM.Repo({
          storage: new AM.IndexedDBStorageAdapter(),
          // network: [new AM.BrowserWebSocketClientAdapter("wss://sync.automerge.org")],
        });

        const find = id => repo.find(id).catch(() => null);

        const library = await repo
          .find(localStorage.getItem("scrapsheets"))
          .catch(async () => {
            const bsky = repo.create({
              name: "Bluesky Firehose",
              type: "feed",
              feed: "websocket",
              tags: ["bluesky", "feed"],
              url: "wss://jetstream2.us-east.bsky.network/subscribe",
            });
            const bets = repo.create({
              name: "Manifold Bets Firehose",
              type: "feed",
              feed: "websocket",
              tags: ["manifold", "feed"],
              url: "wss://api.manifold.markets/ws",
            });
            const markets = repo.create({
              name: "Manifold Markets",
              type: "feed",
              feed: "http",
              tags: ["manifold", "feed"],
              url: "https://api.manifold.markets/v0/markets?limit=50",
            });
            const git = repo.create({
              name: "Scrapscript Commits",
              type: "feed",
              feed: "git",
              tags: ["git", "feed"],
              url: "https://github.com/tekknolagi/scrapscript.git",
            });
            const sheets = [
              // bsky,
              bets,
              markets,
              git,
              repo.create({
                name: "Tasks",
                type: "doc",
                tags: ["doc"],
                cols: [
                  { key: 0, name: "Complete", type: "bool" },
                  { key: 1, name: "Task", type: "text" },
                  { key: 2, name: "Notes", type: "text" },
                ],
                rows: [
                  [true, "Setup project", "Fill out details, etc."],
                  [false, "Create demo", "Prep for pitch"],
                  [false, "Review requirements", "Check with stakeholders"],
                  [true, "Install dependencies", "NPM packages installed"],
                  [false, "Write tests", "Unit and integration tests"],
                  [true, "Configure database", "PostgreSQL setup complete"],
                  [false, "Design wireframes", "Figma mockups needed"],
                  [false, "Implement authentication", "JWT token system"],
                  [true, "Setup CI/CD pipeline", "GitHub Actions configured"],
                  [false, "Code review", "Security audit pending"],
                  [false, "Deploy to staging", "AWS environment ready"],
                  [true, "Update documentation", "API docs completed"],
                  [false, "Performance testing", "Load test scenarios"],
                  [false, "User acceptance testing", "Beta user feedback"],
                  [true, "Setup monitoring", "Datadog integration"],
                  [false, "Optimize images", "Compress and resize assets"],
                  [false, "Implement search", "Elasticsearch integration"],
                  [true, "Setup logging", "Winston logger configured"],
                  [false, "Security scan", "OWASP vulnerability check"],
                  [false, "Deploy to production", "Final release checklist"],
                ],
              }),
              repo.create({
                name: "Budget",
                type: "doc",
                tags: ["doc"],
                cols: [
                  { key: 0, name: "Item", type: "text" },
                  { key: 1, name: "Amount", type: "number" },
                ],
                rows: [
                  ["Groceries", 150],
                  ["Gas", 80],
                  ["Utilities", 120],
                  ["Internet", 65],
                  ["Rent", 1200],
                  ["Insurance", 85],
                  ["Phone", 45],
                  ["Streaming services", 35],
                  ["Gym membership", 30],
                  ["Coffee", 25],
                  ["Dining out", 200],
                  ["Transportation", 100],
                  ["Medical expenses", 75],
                  ["Clothing", 60],
                  ["Entertainment", 50],
                  ["Books", 20],
                  ["Software subscriptions", 40],
                  ["Home supplies", 30],
                  ["Pet food", 45],
                  ["Savings", 300],
                  ["Emergency fund", 200],
                  ["Investment", 250],
                  ["Vacation fund", 100],
                  ["Car maintenance", 70],
                  ["Gifts", 40],
                ],
              }),
              repo.create({
                name: "Sprint",
                type: "doc",
                tags: ["doc"],
                cols: [
                  { key: 0, name: "Project", type: "text" },
                  { key: 1, name: "Priority", type: "text" },
                ],
                rows: [
                  ["Website redesign", "High"],
                  ["Documentation", "Medium"],
                  ["API integration", "High"],
                  ["Bug fixes", "Medium"],
                  ["Performance optimization", "Low"],
                  ["Mobile responsiveness", "High"],
                  ["User dashboard", "High"],
                  ["Payment processing", "Critical"],
                  ["Email notifications", "Medium"],
                  ["Search functionality", "High"],
                  ["Admin panel", "Medium"],
                  ["Database migration", "High"],
                  ["Security audit", "Critical"],
                  ["Analytics integration", "Low"],
                  ["Chat support", "Medium"],
                  ["File upload system", "High"],
                  ["Backup system", "Medium"],
                  ["Load balancing", "Low"],
                  ["Cache optimization", "Medium"],
                  ["Error tracking", "High"],
                  ["User onboarding", "High"],
                  ["Social media integration", "Low"],
                  ["Reporting system", "Medium"],
                  ["Accessibility improvements", "Medium"],
                  ["Internationalization", "Low"],
                  ["Multi-factor authentication", "High"],
                  ["Data export features", "Medium"],
                  ["Third-party integrations", "Low"],
                ],
              }),
              repo.create({
                name: "Bluesky Stats",
                type: "query",
                tags: ["bluesky", "query"],
                query: `
                  from (scrapsheet ${bsky.url})
                  join (unnest s.res.body) true
                  group collection {
                    n = count collection,
                  }
                `,
              }),
              repo.create({
                name: "Employees",
                type: "feed",
                feed: "code",
                tags: ["postgres", "feed"],
                url: "postgresql://localhost",
                lang: "sql",
                code: "select * from employees",
              }),
              repo.create({
                name: "Scrapscript Contributors",
                type: "query",
                tags: ["git", "query"],
                query: `
                  from (scrapsheet ${git.url})
                  group email {
                    n = count email,
                  }
                  select {
                    author, n
                  }
                `,
              }),
              repo.create({
                name: "Manifold Bet Stats",
                type: "query",
                tags: ["manifold", "query"],
                query: `
                  from s = (scrapsheet ${bets.url})
                  join (unnest s.res.body) true
                  group creatorId {
                    n = count creatorId,
                    avg = average TODO,
                  }
                  select {
                    creatorId, n, avg
                  }
                `,
              }),
              repo.create({
                name: "Manifold Market Latest",
                type: "query",
                tags: ["manifold", "query"],
                query: `
                  from (scrapsheet ${markets.url})
                  take 1
                  join (unnest s.res.body) true
                `,
              }),
              repo.create({
                name: "Slides",
                type: "doc",
                tags: ["doc"],
                cols: [{ key: 0, name: "", type: "image" }],
                rows: [
                  ["/-1.png"],
                  ["/0.png"],
                  ["/1.png"],
                  ["/2.png"],
                  ["/3.png"],
                  ["/4.png"],
                  ["/5.png"],
                  ["/6.png"],
                  ["/7.png"],
                  ["/8.png"],
                  ["/9.png"],
                ],
              }),
            ];
            return await repo.create({
              sheets: sheets.map(doc => doc.documentId),
            });
          });
        localStorage.setItem("scrapsheets", library.documentId);

        const hash = window.location.hash.slice(1) || null;
        const app = Elm.Main.init({
          node: document.getElementById("elm"),
          flags: {
            sheet: (await find(hash))?.doc() ?? null,
          },
        });

        {
          let sheet;

          let mouse = {};
          document.addEventListener(
            "mousemove",
            e => {
              mouse = { x: e.pageX, y: e.pageY };
            },
            false,
          );

          setInterval(() => {
            switch (sheet?.documentId) {
              case "device":
                app.ports.sheetChanged.send({
                  id: sheet?.documentId,
                  data: {
                    doc: {
                      name: "Device",
                      type: "doc",
                      cols: [
                        { key: 0, name: "Key", type: "text" },
                        { key: 1, name: "Value", type: "text" },
                      ],
                      rows: [
                        { 0: "Time", 1: new Date().getTime() },
                        { 0: "Mouse X", 1: mouse.x ?? null },
                        { 0: "Mouse Y", 1: mouse.y ?? null },
                        { 0: "Screen Height", 1: window.screen.height },
                        { 0: "Screen Width", 1: window.screen.width },
                      ],
                    },
                    handle: null,
                    patchInfo: null,
                    patches: [],
                  },
                });
                break;
            }
          }, 100);

          // TODO: Figure out how to remove API-specific code.
          let ws;
          app.ports.selectSheet.subscribe(async id => {
            if (id === sheet?.documentId) return;
            ws?.close();
            // TODO: Remove existing listeners.
            sheet = (await find(id)) || { documentId: id };
            let doc = await sheet?.doc?.();
            const top = { ...doc };
            if (doc?.type === "query") {
              const [_, id] = doc?.query?.match(
                /\(scrapsheet automerge:([^\)]*)\)/,
              );
              const sheet_ = (await find(id)) || { documentId: id };
              doc = await sheet_?.doc?.();
            }
            ws = doc?.feed === "websocket" ? new WebSocket(doc?.url) : null;
            if (ws) {
              const rows = [];
              ws.onmessage = event => {
                rows.unshift(JSON.parse(event.data));
                app.ports.sheetChanged.send({
                  id,
                  data: {
                    doc: { ...top, rows },
                    handle: null,
                    patchInfo: null,
                    patches: [],
                  },
                });
              };
              if (doc?.url === "wss://api.manifold.markets/ws")
                ws.onopen = () =>
                  ws.send(
                    JSON.stringify({
                      type: "subscribe",
                      txid: 0,
                      topics: ["global/new-bet"],
                    }),
                  );
            }
            if (doc?.feed === "http")
              top.rows = await fetch(doc?.url).then(res => res.json());
            if (doc?.feed === "git") {
              const url = new URL(doc?.url);
              const [owner, repo] = url.pathname
                .slice(1)
                .replace(".git", "")
                .split("/");
              top.rows = await fetch(
                `https://api.github.com/repos/${owner}/${repo}/commits`,
              )
                .then(res => res.json())
                .then(commits =>
                  commits.map(c => ({
                    hash: c.sha,
                    message: c.commit.message,
                    author: c.commit.author.name,
                    email: c.commit.author.email,
                    date: c.commit.author.date,
                    url: c.html_url,
                  })),
                )
                .catch(() => []);
            }
            if (!sheet || !top) return;
            sheet.on("change", data => {
              app.ports.sheetChanged.send({
                id: data.handle.documentId,
                data,
              });
            });
            app.ports.sheetChanged.send({
              id,
              data: {
                doc: top,
                handle: null,
                patchInfo: null,
                patches: [],
              },
            });
          });

          app?.ports?.changeSheet?.subscribe(
            // TODO: Use custom patches for now.
            ({ id, data: patches }) => {
              if (!id || id !== sheet?.documentId) return;
              for (const patch of patches) {
                sheet?.change(d => {
                  if (!d.cols) d.cols = [];
                  if (!d.rows) d.rows = [];
                  switch (patch.action) {
                    case "cell-put":
                      const [_, y, x] = patch.path;
                      if (!d.rows[y]) d.rows[y] = {};
                      d.rows[y][x] = patch.value;
                      break;
                    case "row-insert":
                      d.rows.insertAt(1 + patch.path[1], patch.value);
                      break;
                    case "col-insert":
                      // TODO: Intelligently pick a column based on existing columns and rows.
                      d.cols.push({
                        key: Math.random().toString().slice(2),
                        label: Math.random().toString().slice(2),
                        type: "same",
                      });
                      break;
                    case "row-del":
                      d.rows.deleteAt(patch.path[1]);
                      break;
                    case "col-del":
                      d.cols.deleteAt(patch.path[1]);
                      break;
                    default:
                      throw new Error("TODO");
                  }
                });
              }
            },
          );
        }

        library.on("change", async data => {
          // TODO: Update books based on patch.
          // const sheetDoc = TODO
          // app.ports.libraryChanged.send({ id: sheetDoc.documentId, data: await sheetDoc.doc() });
        });
        for (const id of (await library.doc()).sheets) {
          const sheet = await find(id);
          if (sheet)
            app.ports.libraryChanged.send({
              id: sheet.documentId,
              data: await sheet.doc(),
            });
        }
      } catch (error) {
        console.error(error);
      }
    </script>
  </body>
</html>
