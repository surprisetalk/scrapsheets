<!doctype html>
<html lang="en">
  <head>
    <title>scrapsheets</title>
    <meta charset="UTF-8" />
    <meta name="author" content="Taylor Troesh" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="dark light" />
    <meta
      name="theme-color"
      content="#ffffff"
      media="(prefers-color-scheme: light)" />
    <meta
      name="theme-color"
      content="#151515"
      media="(prefers-color-scheme: dark)" />
    <link href="/style.css" rel="stylesheet" />
    <script src="/index.js"></script>
  </head>
  <body>
    <div id="elm"></div>
    <script type="module">
      import * as AM from "/automerge.js";

      try {
        const app = Elm.Main.init({
          node: document.getElementById("elm"),
          flags: {},
        });

        const Col = (val, key) => {
          const [name, type] = val.split("::");
          return {
            name: name,
            type: type ?? "string",
            key: key.toString(),
          };
        };

        const Template = (name, type, data) => ({
          type: "template",
          data: [{ type, data }],
        });

        const Scratch = data => ({
          type: "scratch",
          data: [data],
        });

        const Table = (cols, ...rows) => ({
          type: "table",
          data: [cols, ...rows],
        });

        const Library = {
          get: () => {
            const examples = {
              "scratch:table:calculated-columns": {
                name: "calculated columns",
                doc: Scratch(
                  Table(
                    [
                      { key: 0, name: "a", type: "int" },
                      { key: 1, name: "b", type: "int" },
                      {
                        key: 2,
                        name: "c",
                        type: { lang: "formula", code: "a + b" },
                      },
                    ],
                    ...[
                      [1, 2],
                      [2, 4],
                      [3, 6],
                    ],
                  ),
                ),
              },
              "scratch:table:postman": {
                name: "rest api",
                doc: Scratch(
                  Table(
                    [
                      { key: 0, name: "method", type: "text" },
                      { key: 1, name: "url", type: "text" },
                      { key: 2, name: "fields", type: "list field" },
                      {
                        key: 3,
                        name: "form",
                        type: {
                          lang: "scrapscript",
                          code: "form {method,url,fields}",
                        },
                      },
                    ],
                    ...[
                      [
                        "GET",
                        "example.com/foo",
                        [
                          { label: "hello", type: "text" },
                          { label: "world", type: "date" },
                        ],
                      ],
                      [
                        "POST",
                        "example.com/bar",
                        [
                          {
                            label: "my dropdown",
                            key: "my_dropdown",
                            type: { 1: "label a", 2: "label b" },
                            default: 2,
                          },
                        ],
                      ],
                    ],
                  ),
                ),
              },
            };
            return {
              ...examples,
              ...JSON.parse(
                localStorage.getItem("scrapsheets-library") ?? "{}",
              ),
              "": { name: "library", doc: { type: "library" } },
              "portal:shop": { name: "shop" },
              "template:table": {
                name: "table",
                doc: Template("table", "table", ["a", "b", "c"].map(Col)),
              },
              "template:query": {
                name: "template",
                doc: Template("query", "query", [
                  { lang: "sql", code: "select 1 as a", args: [] },
                ]),
              },
              "table:tutorial": {
                name: "tutorial",
                doc: Table(
                  ["text::text", "examples::text"].map(Col),
                  ["chapter 1", []],
                  ["chapter 2", []],
                  ["chapter 3", []],
                ),
              },
              "table:examples": {
                name: "examples",
                doc: Table(
                  ["sheet_id::link", "name::text"].map(Col),
                  ...Object.entries(examples).map(([k, v]) => [k, v.name]),
                ),
              },
            };
          },
          set: (id, info) => {
            for (const i in info) if (info[i] === null) delete info[i];
            const library = JSON.parse(
              localStorage.getItem("scrapsheets-library") ?? "{}",
            );
            localStorage.setItem(
              "scrapsheets-library",
              JSON.stringify({ ...library, [id]: { ...library[id], ...info } }),
            );
            app.ports.librarySynced.send(Library.get());
          },
          delete: id => {
            const library = JSON.parse(
              localStorage.getItem("scrapsheets-library") ?? "{}",
            );
            localStorage.setItem(
              "scrapsheets-library",
              JSON.stringify({ ...library, [id]: undefined }),
            );
            app.ports.librarySynced.send(Library.get());
          },
        };
        app.ports.librarySynced.send(Library.get());

        app.ports.deleteDoc.subscribe(async id => Library.delete(id));

        app.ports.updateLibrary.subscribe(({ id, data }) =>
          Library.set(id, data),
        );

        {
          await AM.initializeWasm(fetch("/automerge.wasm"));

          const repo = new AM.Repo({
            storage: new AM.IndexedDBStorageAdapter(),
            // network: [new AM.BrowserWebSocketClientAdapter("wss://sync.automerge.org")],
          });

          let sheet;

          const queryDoc = async (id, { code, lang, args }) => {
            // TODO: Run alasql if possible, otherwise post to /query.
            app.ports.docQueried.send({
              id,
              data: [[{ name: "a", type: "int", key: "a" }], { a: 1 }],
            });
          };

          const selectDoc = async (id, sheet) => {
            const [type] = id.split(":");
            const doc = Library.get()[id]?.doc ?? (await sheet?.doc?.());
            app.ports.docSelected.send({
              id,
              data: { doc: doc && { ...doc } },
            });
            if (type === "query") queryDoc(id, doc.data);
            sheet?.on?.("change", data => {
              app.ports.docChanged.send({
                id: type + ":" + data.handle.documentId,
                data,
              });
              if (type === "query") queryDoc(id, data.data);
            });
          };

          const changeId = async id => {
            const [, doc_id = ""] = id.split(":");
            if (doc_id === sheet?.documentId) return;
            // TODO: Remove existing listeners.
            sheet = await repo?.find(doc_id).catch(() => null);
            await selectDoc(id, sheet);
          };
          app.ports.changeId.subscribe(changeId);
          changeId(window.location.pathname.slice(1));

          app.ports.newDoc.subscribe(async ({ type, data }) => {
            // TODO: Remove existing listeners.
            sheet = repo?.create({ type, data });
            const id = `${type}:${sheet.documentId}`;
            Library.set(id, { name: "", tags: [] });
            await selectDoc(id, sheet);
          });

          app.ports.changeDoc.subscribe(({ id, data: patches }) => {
            const [type, doc_id] = id.split(":");
            if (!doc_id || doc_id !== sheet?.documentId) return;
            for (const { path, action, value } of patches)
              sheet?.change(d => {
                switch (path.length) {
                  case 0: {
                    d.data[action](...value);
                    break;
                  }
                  case 1: {
                    const [y] = path;
                    if (action === "set") d.data[y] = value;
                    else d.data[y][action](...value);
                    break;
                  }
                  case 2: {
                    const [y, x] = path;
                    if (!d.data[y]) d.data[y] = {};
                    if (action === "set") d.data[y][x] = value;
                    else d.data[y][x][action](...value);
                    break;
                  }
                  default:
                    throw new Error("TODO: path");
                }
              });
          });
        }
      } catch (error) {
        console.error(error);
      }
    </script>
  </body>
</html>
