<!doctype html>
<html lang="en">
  <head>
    <title>scrapsheets</title>
    <meta charset="UTF-8" />
    <meta name="author" content="Taylor Troesh" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="dark light" />
    <meta
      name="theme-color"
      content="#ffffff"
      media="(prefers-color-scheme: light)" />
    <meta
      name="theme-color"
      content="#151515"
      media="(prefers-color-scheme: dark)" />
    <script src="/index.js"></script>
  </head>
  <body>
    <div id="elm"></div>
    <script type="module">
      import * as AM from "https://esm.sh/@automerge/react@2.0.0/slim?bundle-deps";
      await AM.initializeWasm(
        fetch("https://esm.sh/@automerge/automerge/dist/automerge.wasm"),
      );

      try {
        const repo = new AM.Repo({
          storage: new AM.IndexedDBStorageAdapter(),
          // network: [new AM.BrowserWebSocketClientAdapter("wss://sync.automerge.org")],
        });

        const libraryDoc = await repo
          .find(localStorage.getItem("scrapsheets-library-id"))
          .catch(async () => await repo.create({ books: [] }));
        localStorage.setItem("scrapsheets-library-id", libraryDoc.documentId);

        const bookDocs = {};
        for (const id of (await libraryDoc.doc()).books)
          bookDocs[id] = await repo.find(id).catch(() => null);

        const library = async () =>
          Object.fromEntries(
            await Promise.all(
              (await libraryDoc.doc()).books.map(async id => [
                id,
                await bookDocs[id].doc(),
              ]),
            ),
          );

        let sheetDoc = await repo
          .find(window.location.hash.slice(1))
          .catch(() => null);

        const app = Elm.Main.init({
          node: document.getElementById("elm"),
          flags: {
            sheetId: sheetDoc?.documentId ?? null,
            sheet: (await sheetDoc?.doc()) ?? null,
            library: await library(),
          },
        });

        sheetDoc?.on("change", data => {
          const payload = { sheetId: sheetDoc?.documentId, data };
          app.ports.sheetChanged.send(payload);
        });

        for (const id in bookDocs)
          bookDocs[id].on("change", async data =>
            app.ports.libraryChanged.send(await library()),
          );

        libraryDoc.on("change", async data => {
          // TODO: Update books based on patch.
          // TODO: Listen to new books and remove listeners on deleting books.
          app.ports.libraryChanged.send(await library());
        });

        app.ports.selectSheet.subscribe(async sheetId => {
          const newDoc = await repo.find(sheetId).catch(() => null);
          if (newDoc) {
            sheetDoc?.removeAllListeners();
            sheetDoc = newDoc;
            await sheetDoc.isReady();
            sheetDoc.on("change", data => {
              const payload = { sheetId: sheetDoc.documentId, data };
              app.ports.sheetChanged.send(payload);
            });
            const initialPayload = {
              sheetId: sheetDoc.documentId,
              data: {
                doc: await sheetDoc.doc(),
                handle: null,
                patchInfo: null,
                patches: [],
              },
            };
            app.ports.sheetChanged.send(initialPayload);
          }
        });

        app.ports.changeSheet.subscribe(
          // TODO: Use custom patches for now.
          ({ sheetId, data: patches }) => {
            for (const patch of patches) {
              sheetDoc?.change(d => {
                if (!d.cols) d.cols = [];
                if (!d.rows) d.rows = [];
                switch (patch.action) {
                  case "cell-put":
                    const [_, y, x] = patch.path;
                    if (!d.rows[y]) d.rows[y] = {};
                    d.rows[y][x] = patch.value;
                    break;
                  case "row-insert":
                    d.rows.insertAt(1 + patch.path[1], patch.value);
                    break;
                  case "col-insert":
                    // TODO: Intelligently pick a column based on existing columns and rows.
                    d.cols.push({
                      key: Math.random().toString().slice(2),
                      label: Math.random().toString().slice(2),
                      type: "same",
                    });
                    break;
                  case "row-del":
                    d.rows.deleteAt(patch.path[1]);
                    break;
                  case "col-del":
                    d.cols.deleteAt(patch.path[1]);
                    break;
                  default:
                    throw new Error("TODO");
                }
              });
            }
          },
        );

        if (!(await libraryDoc.doc()).books.length) {
          const demoSheet = repo.create({
            cols: [
              { key: "A", label: "Task", type: "text" },
              { key: "B", label: "Status", type: "text" },
            ],
            rows: [
              { A: "Setup project", B: "Done" },
              { A: "Create demo", B: "In Progress" },
            ],
          });
          const budgetSheet = repo.create({
            cols: [
              { key: "A", label: "Item", type: "text" },
              { key: "B", label: "Amount", type: "number" },
            ],
            rows: [
              { A: "Groceries", B: "150" },
              { A: "Gas", B: "80" },
            ],
          });
          const taskSheet = repo.create({
            cols: [
              { key: "A", label: "Project", type: "text" },
              { key: "B", label: "Priority", type: "text" },
            ],
            rows: [
              { A: "Website redesign", B: "High" },
              { A: "Documentation", B: "Medium" },
            ],
          });

          const personalBook = repo.create({
            dir: "taylor",
            sheets: {
              [demoSheet.documentId]: {
                name: "Demo Sheet",
                tags: ["demo", "example"],
                thumb: null,
              },
              [budgetSheet.documentId]: {
                name: "Budget Tracker",
                tags: ["finance", "personal"],
                thumb: null,
              },
            },
          });
          const workBook = repo.create({
            dir: "work",
            sheets: {
              [taskSheet.documentId]: {
                name: "Project Tasks",
                tags: ["project", "tasks"],
                thumb: null,
              },
            },
          });
          const recipesBook = repo.create({
            dir: "recipes",
            sheets: {},
          });

          libraryDoc.change(d =>
            d.books.push(
              personalBook.documentId,
              workBook.documentId,
              recipesBook.documentId,
            ),
          );
        }
      } catch (error) {
        console.error(error);
      }
    </script>
  </body>
</html>
